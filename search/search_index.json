{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the documentation for kubenav kubenav is the navigator for your Kubernetes clusters right in your pocket. kubenav is a mobile, desktop and web app to manage Kubernetes clusters and to get an overview of the status of your resources. kubenav is a mobile, desktop and web app to manage Kubernetes clusters. The app provides an overview of all resources in a Kubernetes clusters, including current status information for workloads. The details view for resources provides additional information. It is possible to view logs and events or to get a shell into a container. You can also edit and delete resources or scale your workloads within the app. The app is developed using Ionic Framework and Capacitor . The frontend part of the app is implemented using TypeScript and React functional components. The backend part uses Go mobile for communication with the Kubernetes API server and Cloud Providers. So it is possible to achieve nearly 100% code sharing between the mobile and desktop implementation of kubenav. Features Available for mobile, desktop and web: kubenav provides the same experience for mobile, desktop and web, with nearly 100% code sharing. Manage Resources: All major resources like Deployments, StatefulSets, DaemonSets, Pods, etc. are supported. Custom Resource Definitions: View all Custom Resource Definitions and mange Custom Resources. Modify Resources: Edit and delete all available resources or scale your Deployments, StatefulSets, DaemonSets. Filter and Search: Filter the resources by Namespace and find them by there name. Status Information: Fast overview of the status of workloads and detailed information including Events. Resource Usage: View the requests, limits and current usage of Pods and Containers. Logs: View the logs of a container or stream the logs in realtime. Terminal: Get a shell into a container, right from your phone. Manage multiple Clusters: Add multiple clusters via kubeconfig or your prefered Cloud Provider, including Google, AWS and Azure. Port-Forwarding: Create a port-forwarding connection to one of your Pods and open the served page in your browser. Prometheus Integration: kubenav allows you to view your Prometheus metrics directly in the dashboard and to build your own dashboards via the Prometheus plugin. Elasticsearch Integration: Discover your logs with the Elasticsearch plugin. Jaeger Integration: Analyze your traces with the Jaeger plugin. Content Mobile : kubenav is available for iOS and Android via the App Store and Google Play . The documentaion for the mobile version can be found in this section. Desktop : This section contains the documentation for the Desktop version of kubenav. Web : If you want to use the web version of kubenav, this is your starting point. Contributing : We love your input. If you want to start contributing, this is your place to go. Repositories kubenav/kubenav : The main repository for kubenav. This repository contains the complete code for the mobile, desktop and web version of kubenav. kubenav/deploy : This repository contains the Kustomize files and the Helm Chart for kubenav. kubenav/docs : This repository contains the documentation for kubenav, which is available at docs.kubenav.io . kubenav/kubenav.io : This repository contains the landing page for kubenav and is available at kubenav.io . kubenav/helm-repository : This repository contains all published Helm Charts.","title":"Home"},{"location":"#welcome-to-the-documentation-for-kubenav","text":"kubenav is the navigator for your Kubernetes clusters right in your pocket. kubenav is a mobile, desktop and web app to manage Kubernetes clusters and to get an overview of the status of your resources. kubenav is a mobile, desktop and web app to manage Kubernetes clusters. The app provides an overview of all resources in a Kubernetes clusters, including current status information for workloads. The details view for resources provides additional information. It is possible to view logs and events or to get a shell into a container. You can also edit and delete resources or scale your workloads within the app. The app is developed using Ionic Framework and Capacitor . The frontend part of the app is implemented using TypeScript and React functional components. The backend part uses Go mobile for communication with the Kubernetes API server and Cloud Providers. So it is possible to achieve nearly 100% code sharing between the mobile and desktop implementation of kubenav.","title":"Welcome to the documentation for kubenav"},{"location":"#features","text":"Available for mobile, desktop and web: kubenav provides the same experience for mobile, desktop and web, with nearly 100% code sharing. Manage Resources: All major resources like Deployments, StatefulSets, DaemonSets, Pods, etc. are supported. Custom Resource Definitions: View all Custom Resource Definitions and mange Custom Resources. Modify Resources: Edit and delete all available resources or scale your Deployments, StatefulSets, DaemonSets. Filter and Search: Filter the resources by Namespace and find them by there name. Status Information: Fast overview of the status of workloads and detailed information including Events. Resource Usage: View the requests, limits and current usage of Pods and Containers. Logs: View the logs of a container or stream the logs in realtime. Terminal: Get a shell into a container, right from your phone. Manage multiple Clusters: Add multiple clusters via kubeconfig or your prefered Cloud Provider, including Google, AWS and Azure. Port-Forwarding: Create a port-forwarding connection to one of your Pods and open the served page in your browser. Prometheus Integration: kubenav allows you to view your Prometheus metrics directly in the dashboard and to build your own dashboards via the Prometheus plugin. Elasticsearch Integration: Discover your logs with the Elasticsearch plugin. Jaeger Integration: Analyze your traces with the Jaeger plugin.","title":"Features"},{"location":"#content","text":"Mobile : kubenav is available for iOS and Android via the App Store and Google Play . The documentaion for the mobile version can be found in this section. Desktop : This section contains the documentation for the Desktop version of kubenav. Web : If you want to use the web version of kubenav, this is your starting point. Contributing : We love your input. If you want to start contributing, this is your place to go.","title":"Content"},{"location":"#repositories","text":"kubenav/kubenav : The main repository for kubenav. This repository contains the complete code for the mobile, desktop and web version of kubenav. kubenav/deploy : This repository contains the Kustomize files and the Helm Chart for kubenav. kubenav/docs : This repository contains the documentation for kubenav, which is available at docs.kubenav.io . kubenav/kubenav.io : This repository contains the landing page for kubenav and is available at kubenav.io . kubenav/helm-repository : This repository contains all published Helm Charts.","title":"Repositories"},{"location":"screenshots/","text":"Screenshots On the following page you can found some screenshots for the desktop and mobile version of kubenav. Desktop Mobile","title":"Screenshots"},{"location":"screenshots/#screenshots","text":"On the following page you can found some screenshots for the desktop and mobile version of kubenav.","title":"Screenshots"},{"location":"screenshots/#desktop","text":"","title":"Desktop"},{"location":"screenshots/#mobile","text":"","title":"Mobile"},{"location":"contributing/development/","text":"Development kubenav requires Node v8.6.0 or later, and NPM version 5.6.0 or later (which is usually automatically installed with the required version of Node). If there is a previous installation of the Ionic CLI installed, it will need to be uninstalled due to a change in package name for ionic/cli: npm uninstall -g ionic If you have Node and NPM installed, install Ionic CLI: npm install -g @ionic/cli Besides Node, kubenav requires Go 1.14 or later and Go mobile , which can be installed using the following commands: go get -u golang.org/x/mobile/cmd/gomobile go install golang.org/x/mobile/cmd/gomobile gomobile init To build the Electron version of kubenav, install the go-astilectron-bundler : go get -u github.com/asticode/go-astilectron-bundler/... go install github.com/asticode/go-astilectron-bundler/astilectron-bundler To build the iOS version of kubenav ensure that you have Xcode and CocoaPods installed. For the Android version you need the Android SDK, which can be installed via Android Studio and the NDK . Also ensure that the ANDROID_HOME and ANDROID_NDK_HOME environment variables are set. Clone the repository, login to GitHub packages and install the required dependencies: git clone git@github.com:kubenav/kubenav.git cd kubenav npm install You must build the kubenav project at least once before running on any native platform: ionic build You may then build the relevant mobile platform you require make bindings-android make bindings-ios To use kubenav in your browser you need to build and start the server. The server listening on port 14122 : make build-server && ./bin/server Now you can start the app and open localhost:8100 in your browser: ionic serve Every time you perform a build (e.g. ionic build ) that changes your web directory (default: build ), you'll need to copy those changes down to your native projects: npx cap sync The native iOS and Android projects are opened in their standard IDEs (Xcode and Android Studio, respectively). Use the IDEs to run kubenav: npx cap open ios npx cap open android You can also run the native iOS or Android app with live reloading: ionic capacitor run android -l --address=0.0.0.0 ionic capacitor run ios -l --address=0.0.0.0 To build the Electron version of kubenav run make build-electron . The app can be found in the cmd/electron/output/<PLATFORM>-amd64 folder: make build-electron","title":"Development"},{"location":"contributing/development/#development","text":"kubenav requires Node v8.6.0 or later, and NPM version 5.6.0 or later (which is usually automatically installed with the required version of Node). If there is a previous installation of the Ionic CLI installed, it will need to be uninstalled due to a change in package name for ionic/cli: npm uninstall -g ionic If you have Node and NPM installed, install Ionic CLI: npm install -g @ionic/cli Besides Node, kubenav requires Go 1.14 or later and Go mobile , which can be installed using the following commands: go get -u golang.org/x/mobile/cmd/gomobile go install golang.org/x/mobile/cmd/gomobile gomobile init To build the Electron version of kubenav, install the go-astilectron-bundler : go get -u github.com/asticode/go-astilectron-bundler/... go install github.com/asticode/go-astilectron-bundler/astilectron-bundler To build the iOS version of kubenav ensure that you have Xcode and CocoaPods installed. For the Android version you need the Android SDK, which can be installed via Android Studio and the NDK . Also ensure that the ANDROID_HOME and ANDROID_NDK_HOME environment variables are set. Clone the repository, login to GitHub packages and install the required dependencies: git clone git@github.com:kubenav/kubenav.git cd kubenav npm install You must build the kubenav project at least once before running on any native platform: ionic build You may then build the relevant mobile platform you require make bindings-android make bindings-ios To use kubenav in your browser you need to build and start the server. The server listening on port 14122 : make build-server && ./bin/server Now you can start the app and open localhost:8100 in your browser: ionic serve Every time you perform a build (e.g. ionic build ) that changes your web directory (default: build ), you'll need to copy those changes down to your native projects: npx cap sync The native iOS and Android projects are opened in their standard IDEs (Xcode and Android Studio, respectively). Use the IDEs to run kubenav: npx cap open ios npx cap open android You can also run the native iOS or Android app with live reloading: ionic capacitor run android -l --address=0.0.0.0 ionic capacitor run ios -l --address=0.0.0.0 To build the Electron version of kubenav run make build-electron . The app can be found in the cmd/electron/output/<PLATFORM>-amd64 folder: make build-electron","title":"Development"},{"location":"contributing/getting-started/","text":"Getting started Every contribution to kubenav is welcome, whether it is reporting a bug, submitting a fix, proposing new features or becoming a maintainer. To make contributing to kubenav as easy as possible you will find more details for the development flow in this documentation. Please follow our Contribution Guideline and our Code of Conduct in all your interactions with the project.","title":"Getting started"},{"location":"contributing/getting-started/#getting-started","text":"Every contribution to kubenav is welcome, whether it is reporting a bug, submitting a fix, proposing new features or becoming a maintainer. To make contributing to kubenav as easy as possible you will find more details for the development flow in this documentation. Please follow our Contribution Guideline and our Code of Conduct in all your interactions with the project.","title":"Getting started"},{"location":"contributing/release/","text":"Releases Every new release is created from the master branch. To create a new release the version field in the package.json file must be updated and a new tag must be set. This process is automated via a Makefile : make release-patch make release-minor make release-major When the tag is pushed the changelog will be generated via GitHub Action and saved to the CHANGELOG.md file. When the changelog was generated a new GitHub release can be created with the following naming scheme and the changelog for the current tag as description: Version <TAG> (yyyy-mm-dd) After the release was created another GitHub Action is executed to create the Electron app for macOS, Linux and Windows via go-astilectron-bundler . These files are added to the corresponding release. The following files are available for each release: kubenav-darwin-amd64.tar.gz kubenav-linux-amd64.tar.gz kubenav-windows-amd64.tar.gz Next to the binaries for the desktop version, we are also running a GitHub Action to push a new Docker image to Docker Hub with the following name: kubenav/kubenav:<TAG> . The native iOS and Android app is built manually and submitted to the App Store and Google Play. To prepare the native app, run the following commands: make bindings-android make bindings-ios export REACT_APP_VERSION=<TAG> ionic build npx cap sync npx cap open ios npx cap open android In the standard IDE for iOS (Xcode) and Android (Android Studio) run a clean build and follow the steps to publish the app. Beta Release We are building the binaries for each submitted PR and on a nightly schedule . To test new feature you can always download the binaries from the corresponding GitHub Action. We are also pushing a new Docker image for each master commit to Docker Hub . The images are taged with the corresponding commit hash. To publish a new beta version for iOS and Android you can follow the same steps as for a normal release, except that you have to run make release-beta . The beta versions are available via Apple Testflight and Google Play . Changelog The changelog will be generated via GitHub Action, but sometimes it is useful to generate the CHANGELOG.md file locally, before a new tag is created. This can be done with the following command: docker run -it --rm -v \"$(pwd)\":/usr/local/src/your-app ferrarimarco/github-changelog-generator --user=kubenav --project=kubenav --token=<TOKEN>","title":"Release"},{"location":"contributing/release/#releases","text":"Every new release is created from the master branch. To create a new release the version field in the package.json file must be updated and a new tag must be set. This process is automated via a Makefile : make release-patch make release-minor make release-major When the tag is pushed the changelog will be generated via GitHub Action and saved to the CHANGELOG.md file. When the changelog was generated a new GitHub release can be created with the following naming scheme and the changelog for the current tag as description: Version <TAG> (yyyy-mm-dd) After the release was created another GitHub Action is executed to create the Electron app for macOS, Linux and Windows via go-astilectron-bundler . These files are added to the corresponding release. The following files are available for each release: kubenav-darwin-amd64.tar.gz kubenav-linux-amd64.tar.gz kubenav-windows-amd64.tar.gz Next to the binaries for the desktop version, we are also running a GitHub Action to push a new Docker image to Docker Hub with the following name: kubenav/kubenav:<TAG> . The native iOS and Android app is built manually and submitted to the App Store and Google Play. To prepare the native app, run the following commands: make bindings-android make bindings-ios export REACT_APP_VERSION=<TAG> ionic build npx cap sync npx cap open ios npx cap open android In the standard IDE for iOS (Xcode) and Android (Android Studio) run a clean build and follow the steps to publish the app.","title":"Releases"},{"location":"contributing/release/#beta-release","text":"We are building the binaries for each submitted PR and on a nightly schedule . To test new feature you can always download the binaries from the corresponding GitHub Action. We are also pushing a new Docker image for each master commit to Docker Hub . The images are taged with the corresponding commit hash. To publish a new beta version for iOS and Android you can follow the same steps as for a normal release, except that you have to run make release-beta . The beta versions are available via Apple Testflight and Google Play .","title":"Beta Release"},{"location":"contributing/release/#changelog","text":"The changelog will be generated via GitHub Action, but sometimes it is useful to generate the CHANGELOG.md file locally, before a new tag is created. This can be done with the following command: docker run -it --rm -v \"$(pwd)\":/usr/local/src/your-app ferrarimarco/github-changelog-generator --user=kubenav --project=kubenav --token=<TOKEN>","title":"Changelog"},{"location":"desktop/command-line-flags/","text":"Command-Line Flags The desktopversion of kubenav supports the following command-line flags: kubenav - the navigator for your Kubernetes clusters right in your pocket. Usage: kubenav [flags] kubenav [command] Available Commands: help Help about any command version Print version information for kubenav. Flags: --debug Enable debug mode. -h, --help help for kubenav --kubeconfig string Optional Kubeconfig file. --kubeconfig.exclude string Comma separated list of globs to exclude from the Kubeconfig. This flag must be used in combination with the '--kubeconfig.include' flag. --kubeconfig.include string Comma separated list of globs to include in the Kubeconfig. --kubeconfig.sync Sync the changes from kubenav with the used Kubeconfig file. Use \"kubenav [command] --help\" for more information about a command.","title":"Command-Line Flags"},{"location":"desktop/command-line-flags/#command-line-flags","text":"The desktopversion of kubenav supports the following command-line flags: kubenav - the navigator for your Kubernetes clusters right in your pocket. Usage: kubenav [flags] kubenav [command] Available Commands: help Help about any command version Print version information for kubenav. Flags: --debug Enable debug mode. -h, --help help for kubenav --kubeconfig string Optional Kubeconfig file. --kubeconfig.exclude string Comma separated list of globs to exclude from the Kubeconfig. This flag must be used in combination with the '--kubeconfig.include' flag. --kubeconfig.include string Comma separated list of globs to include in the Kubeconfig. --kubeconfig.sync Sync the changes from kubenav with the used Kubeconfig file. Use \"kubenav [command] --help\" for more information about a command.","title":"Command-Line Flags"},{"location":"desktop/configuration/","text":"Configuration The desktop version of kubenav will automatic load all configured clusters from the default Kubeconfig file at ~/.kube/config or the KUBECONFIG environment variable. If you want to use another Kubeconfig file, you can start kubenav with the --kubeconfig flag. You can also use the --kubeconfig.include and --kubeconfig.exclude flag to load Kubeconfig files from multiple locations by glob. The following example loads all Kubeconfig files which are starting with kube from the ~/Documents/kubeconfigs-prod and ~/Documents/kubeconfigs-dev folder: kubenav --kubeconfig.include ~/Documents/kubeconfigs-prod/kube*,~/Documents/kubeconfigs-dev/kube* The --kubeconfig.sync flag can be used to write context changes back to your Kubeconfig file, so the context is also changed in your terminal. Attention kubenav is based on Electron and go-astilectron, which will be downloaded on the first start of the app. Therefore the first start of the app can take a bit longer with a slow internet connection.","title":"Configuration"},{"location":"desktop/configuration/#configuration","text":"The desktop version of kubenav will automatic load all configured clusters from the default Kubeconfig file at ~/.kube/config or the KUBECONFIG environment variable. If you want to use another Kubeconfig file, you can start kubenav with the --kubeconfig flag. You can also use the --kubeconfig.include and --kubeconfig.exclude flag to load Kubeconfig files from multiple locations by glob. The following example loads all Kubeconfig files which are starting with kube from the ~/Documents/kubeconfigs-prod and ~/Documents/kubeconfigs-dev folder: kubenav --kubeconfig.include ~/Documents/kubeconfigs-prod/kube*,~/Documents/kubeconfigs-dev/kube* The --kubeconfig.sync flag can be used to write context changes back to your Kubeconfig file, so the context is also changed in your terminal. Attention kubenav is based on Electron and go-astilectron, which will be downloaded on the first start of the app. Therefore the first start of the app can take a bit longer with a slow internet connection.","title":"Configuration"},{"location":"desktop/getting-started/","text":"Getting started We are providing prebuilt binaries for macOS, Linux and Windows. The binaries for the desktop version of kubenav are available through the release page in the kubenav/kubenav repository. When you want to test new features you can also use a build from the nightly schedule. The nightly builds are created via GitHub Action and can be found at https://github.com/kubenav/kubenav/actions . If you are using homebrew in a Mac, you can also install kubenav with brew install kubenav","title":"Getting started"},{"location":"desktop/getting-started/#getting-started","text":"We are providing prebuilt binaries for macOS, Linux and Windows. The binaries for the desktop version of kubenav are available through the release page in the kubenav/kubenav repository. When you want to test new features you can also use a build from the nightly schedule. The nightly builds are created via GitHub Action and can be found at https://github.com/kubenav/kubenav/actions . If you are using homebrew in a Mac, you can also install kubenav with brew install kubenav","title":"Getting started"},{"location":"desktop/settings/","text":"Settings kubenav provides multiple settings, to customize the look and usage of the app. General Setting Description Values Default Theme Set the theme which should be used for kubenav. System , Dark , Light System Request Timeout (in seconds) The maximum time in seconds for a request. 10 - 120 60 Terminal Font Size (in px) The font size for the terminal. 8 - 48 12 Terminal Scrollback (in lines) The maximum number of lines to scrollback in the terminal. 1000 - 50000 10000 Enable Pod Metrics Enables or disables the metrics for Pods in list views. true , false true Limit The maximum number of items which can be queried per request. 100 - 1000 100 Refresh Interval (in seconds) The interval in which the data of views is refreshed. 30 - 600 300 SSH Setting Description Default Port The port, which should be used for the SSH connection. 22 Private Key The private key, which should be used for the SSH connection. User The name of the user, which should be used for the SSH connection. Prometheus Setting Description Default Enabled Enables or disables the Prometheus plugin. false Namespace The namespace, where Prometheus is running. monitoring Selector The selector, which matches the Prometheus Pod. app=prometheus Port The port, where the Prometheus API is exposed. 9090 Username Username for Prometheus, when the Prometheus endpoint is protected via Basic Authentication. Password Password for Prometheus, when the Prometheus endpoint is protected via Basic Authentication. Dashboards Namespace The namespace, where kubenav should look for dashboards. kubenav Elasticsearch Setting Description Default Enabled Enables or disables the Elasticsearch plugin. false Namespace The namespace, where Elasticsearch is running. logging Selector The selector, which matches the Elasticsearch Pod. app=elasticsearch Port The port, where the Elasticsearch API is exposed. 9200 Username Username for Elasticsearch, when the Elasticsearch endpoint is protected via Basic Authentication. Password Password for Elasticsearch, when the Elasticsearch endpoint is protected via Basic Authentication. Jaeger Setting Description Default Enabled Enables or disables the Jaeger plugin. false Namespace The namespace, where Jaeger is running. tracing Selector The selector, which matches the Jaeger Pod. app=jaeger,app.kubernetes.io/component=query Port The port, where the Jaeger API is exposed. 16686 Username Username for Jaeger, when the Jaeger endpoint is protected via Basic Authentication. Password Password for Jaeger, when the Jaeger endpoint is protected via Basic Authentication. Query Base Path The base path for all Jaeger Query HTTP routes. This must be the same as the --query.base-path command line parameter or the QUERY_BASE_PATH environment variable. Proxy Setting Description Enabled When the proxy setting is enabled, all requests are using the configured proxy. Address The address of the proxy.","title":"Settings"},{"location":"desktop/settings/#settings","text":"kubenav provides multiple settings, to customize the look and usage of the app.","title":"Settings"},{"location":"desktop/settings/#general","text":"Setting Description Values Default Theme Set the theme which should be used for kubenav. System , Dark , Light System Request Timeout (in seconds) The maximum time in seconds for a request. 10 - 120 60 Terminal Font Size (in px) The font size for the terminal. 8 - 48 12 Terminal Scrollback (in lines) The maximum number of lines to scrollback in the terminal. 1000 - 50000 10000 Enable Pod Metrics Enables or disables the metrics for Pods in list views. true , false true Limit The maximum number of items which can be queried per request. 100 - 1000 100 Refresh Interval (in seconds) The interval in which the data of views is refreshed. 30 - 600 300","title":"General"},{"location":"desktop/settings/#ssh","text":"Setting Description Default Port The port, which should be used for the SSH connection. 22 Private Key The private key, which should be used for the SSH connection. User The name of the user, which should be used for the SSH connection.","title":"SSH"},{"location":"desktop/settings/#prometheus","text":"Setting Description Default Enabled Enables or disables the Prometheus plugin. false Namespace The namespace, where Prometheus is running. monitoring Selector The selector, which matches the Prometheus Pod. app=prometheus Port The port, where the Prometheus API is exposed. 9090 Username Username for Prometheus, when the Prometheus endpoint is protected via Basic Authentication. Password Password for Prometheus, when the Prometheus endpoint is protected via Basic Authentication. Dashboards Namespace The namespace, where kubenav should look for dashboards. kubenav","title":"Prometheus"},{"location":"desktop/settings/#elasticsearch","text":"Setting Description Default Enabled Enables or disables the Elasticsearch plugin. false Namespace The namespace, where Elasticsearch is running. logging Selector The selector, which matches the Elasticsearch Pod. app=elasticsearch Port The port, where the Elasticsearch API is exposed. 9200 Username Username for Elasticsearch, when the Elasticsearch endpoint is protected via Basic Authentication. Password Password for Elasticsearch, when the Elasticsearch endpoint is protected via Basic Authentication.","title":"Elasticsearch"},{"location":"desktop/settings/#jaeger","text":"Setting Description Default Enabled Enables or disables the Jaeger plugin. false Namespace The namespace, where Jaeger is running. tracing Selector The selector, which matches the Jaeger Pod. app=jaeger,app.kubernetes.io/component=query Port The port, where the Jaeger API is exposed. 16686 Username Username for Jaeger, when the Jaeger endpoint is protected via Basic Authentication. Password Password for Jaeger, when the Jaeger endpoint is protected via Basic Authentication. Query Base Path The base path for all Jaeger Query HTTP routes. This must be the same as the --query.base-path command line parameter or the QUERY_BASE_PATH environment variable.","title":"Jaeger"},{"location":"desktop/settings/#proxy","text":"Setting Description Enabled When the proxy setting is enabled, all requests are using the configured proxy. Address The address of the proxy.","title":"Proxy"},{"location":"mobile/amazon-web-services/","text":"Amazon Web Services To use the Amazon Web Services provider to import your EKS cluster you have to provide the following AWS credentials: Value Description Access Key ID Access key for AWS. Secret Key A secret key which corresponds to your Access Key ID . Region Your AWS region. These credentials are also used to mange the authentication against the Kubernetes API server of your EKS cluster. So make sure that the Access Key ID has the rights to get a list of your EKS clusters and to access your cluster. AWS Single Sign-On You can also use AWS Single Sign-On within kubenav, for that you have to provide the following settings: Value Description Start URL The start URL for AWS Single Sign-On process. Account ID Is the ID of your AWS account. Role Name Is the name of a role, which is connected with your AWS SSO account. SSO Region The AWS region, where you configured SSO. Region The region for your Kubernetes cluster.","title":"Amazon Web Services"},{"location":"mobile/amazon-web-services/#amazon-web-services","text":"To use the Amazon Web Services provider to import your EKS cluster you have to provide the following AWS credentials: Value Description Access Key ID Access key for AWS. Secret Key A secret key which corresponds to your Access Key ID . Region Your AWS region. These credentials are also used to mange the authentication against the Kubernetes API server of your EKS cluster. So make sure that the Access Key ID has the rights to get a list of your EKS clusters and to access your cluster.","title":"Amazon Web Services"},{"location":"mobile/amazon-web-services/#aws-single-sign-on","text":"You can also use AWS Single Sign-On within kubenav, for that you have to provide the following settings: Value Description Start URL The start URL for AWS Single Sign-On process. Account ID Is the ID of your AWS account. Role Name Is the name of a role, which is connected with your AWS SSO account. SSO Region The AWS region, where you configured SSO. Region The region for your Kubernetes cluster.","title":"AWS Single Sign-On"},{"location":"mobile/cluster-management/","text":"Cluster Management The following page shows, how you can add, edit or delete a cluster and how you can switch between clusters and namespaces. Add Cluster To add a new cluster, you have to select the Clusters (1) item from the menu. Then you can add a new cluster via the plus icon (2) . Details to the different configuration options can be found on the following pages: Google Amazon Web Services Microsoft Azure DigitalOcean OIDC Kubeconfig Manual Edit Cluster To edit a cluster, you have to select the Clusters (1) item from the menu. Then you can swipe left the cluster and select the Edit (2) button, which becomes visible. Delete Cluster To delete a cluster, you have to select the Clusters (1) item from the menu. Then you can swipe left the cluster and select the Delete (2) button, which becomes visible. Change Cluster To change the active cluster, you have to select the Clusters (1) item from the menu. Then you can select the cluster (2) , which should be the active cluster. You can also change a cluster, by selecting the current cluster (1) from the menu. Then a action sheet will become visible, where you have to select the new active cluster (2) . Change Namespace You can change the namespace in each list view of a namespaced resource. To change the namespace, select the options icon (1) and then the namespace from from the popover (2) . Attention This options requires the permission to list all namespaces. If you haven't this right you can choose the method from below, to change the namespace. To change the active cluster, you have to select the Clusters item from the menu. Then swipe the cluster to the left and select Edit . In the modal, which becomes visible scroll to the bottom and enter the name of the namespace in the Namespace field.","title":"Cluster Management"},{"location":"mobile/cluster-management/#cluster-management","text":"The following page shows, how you can add, edit or delete a cluster and how you can switch between clusters and namespaces.","title":"Cluster Management"},{"location":"mobile/cluster-management/#add-cluster","text":"To add a new cluster, you have to select the Clusters (1) item from the menu. Then you can add a new cluster via the plus icon (2) . Details to the different configuration options can be found on the following pages: Google Amazon Web Services Microsoft Azure DigitalOcean OIDC Kubeconfig Manual","title":"Add Cluster"},{"location":"mobile/cluster-management/#edit-cluster","text":"To edit a cluster, you have to select the Clusters (1) item from the menu. Then you can swipe left the cluster and select the Edit (2) button, which becomes visible.","title":"Edit Cluster"},{"location":"mobile/cluster-management/#delete-cluster","text":"To delete a cluster, you have to select the Clusters (1) item from the menu. Then you can swipe left the cluster and select the Delete (2) button, which becomes visible.","title":"Delete Cluster"},{"location":"mobile/cluster-management/#change-cluster","text":"To change the active cluster, you have to select the Clusters (1) item from the menu. Then you can select the cluster (2) , which should be the active cluster. You can also change a cluster, by selecting the current cluster (1) from the menu. Then a action sheet will become visible, where you have to select the new active cluster (2) .","title":"Change Cluster"},{"location":"mobile/cluster-management/#change-namespace","text":"You can change the namespace in each list view of a namespaced resource. To change the namespace, select the options icon (1) and then the namespace from from the popover (2) . Attention This options requires the permission to list all namespaces. If you haven't this right you can choose the method from below, to change the namespace. To change the active cluster, you have to select the Clusters item from the menu. Then swipe the cluster to the left and select Edit . In the modal, which becomes visible scroll to the bottom and enter the name of the namespace in the Namespace field.","title":"Change Namespace"},{"location":"mobile/digital-ocean/","text":"DigitalOcean To use the DigitalOcean provider you have to provide a personal access token: Value Description Personal Access Token Personal Access Token to access the DigitalOcean API. It is enough if the token has the read scope.","title":"DigitalOcean"},{"location":"mobile/digital-ocean/#digitalocean","text":"To use the DigitalOcean provider you have to provide a personal access token: Value Description Personal Access Token Personal Access Token to access the DigitalOcean API. It is enough if the token has the read scope.","title":"DigitalOcean"},{"location":"mobile/getting-started/","text":"Getting started The mobile version of kubenav is available for iOS and Android. The app can be downloaded from the App Store and Google Play . You can also download a beta version of kubenav via Apple Testflight and Google Play to test new features before they are published.","title":"Getting started"},{"location":"mobile/getting-started/#getting-started","text":"The mobile version of kubenav is available for iOS and Android. The app can be downloaded from the App Store and Google Play . You can also download a beta version of kubenav via Apple Testflight and Google Play to test new features before they are published.","title":"Getting started"},{"location":"mobile/google/","text":"Google You can directly import your GKA clusters from Google Cloud. To import your GKE clusters you have to provide a valide Client ID from a Google OAuth 2.0 application. The instructions on how to configure such an application can be found in the following. Value Description Client ID A valid client id from an application, which was created via the Google Cloud Console . Google OAuth 2.0 Configuration Login to the Google Cloud Console and choose API & Services and then OAuth consent screen from the menu. Click on EDIT APP and add https://www.googleapis.com/auth/cloud-platform to the Scopes for Google APIs section. Then save your OAuth consent screen. Select the Credentials item from the menu to get a new Client ID. Then click on CREATE CREDENTIALS and select OAuth client ID . iOS Use the following settings for iOS: Name: iOS-Client Bundle ID: io.kubenav.kubenav App Store ID: 1494512160 Team ID: 75AP6HWLUD When you confirm your settings, via a click on the Create button, a modal opens with the Client ID you can use for kubenav. Android Use the following settings for Android: Name: Android-Client SHA-1 certificate fingerprint: B1:DA:29:60:CC:C8:18:A4:67:AD:BB:34:77:BB:2C:61:16:BA:CD:6B Package name: io.kubenav.kubenav Attention If you get an error message \"Duplicate fingerprint: The fingerprint you specified is already used by an Android OAuth2 client ID in this project or another project\" select another SHA-1 certificate fingerprint. When you confirm your settings, via a click on the Create button, a modal opens with the Client ID you can use for kubenav. Activate APIs In the last step you need to enable the Kubernetes Engine API and the Cloud Resource Manager API : Kubernetes Engine API: https://console.cloud.google.com/apis/library/container.googleapis.com Cloud Resource Manager API: https://console.cloud.google.com/apis/library/cloudresourcemanager.googleapis.com","title":"Google"},{"location":"mobile/google/#google","text":"You can directly import your GKA clusters from Google Cloud. To import your GKE clusters you have to provide a valide Client ID from a Google OAuth 2.0 application. The instructions on how to configure such an application can be found in the following. Value Description Client ID A valid client id from an application, which was created via the Google Cloud Console .","title":"Google"},{"location":"mobile/google/#google-oauth-20-configuration","text":"Login to the Google Cloud Console and choose API & Services and then OAuth consent screen from the menu. Click on EDIT APP and add https://www.googleapis.com/auth/cloud-platform to the Scopes for Google APIs section. Then save your OAuth consent screen. Select the Credentials item from the menu to get a new Client ID. Then click on CREATE CREDENTIALS and select OAuth client ID .","title":"Google OAuth 2.0 Configuration"},{"location":"mobile/google/#ios","text":"Use the following settings for iOS: Name: iOS-Client Bundle ID: io.kubenav.kubenav App Store ID: 1494512160 Team ID: 75AP6HWLUD When you confirm your settings, via a click on the Create button, a modal opens with the Client ID you can use for kubenav.","title":"iOS"},{"location":"mobile/google/#android","text":"Use the following settings for Android: Name: Android-Client SHA-1 certificate fingerprint: B1:DA:29:60:CC:C8:18:A4:67:AD:BB:34:77:BB:2C:61:16:BA:CD:6B Package name: io.kubenav.kubenav Attention If you get an error message \"Duplicate fingerprint: The fingerprint you specified is already used by an Android OAuth2 client ID in this project or another project\" select another SHA-1 certificate fingerprint. When you confirm your settings, via a click on the Create button, a modal opens with the Client ID you can use for kubenav.","title":"Android"},{"location":"mobile/google/#activate-apis","text":"In the last step you need to enable the Kubernetes Engine API and the Cloud Resource Manager API : Kubernetes Engine API: https://console.cloud.google.com/apis/library/container.googleapis.com Cloud Resource Manager API: https://console.cloud.google.com/apis/library/cloudresourcemanager.googleapis.com","title":"Activate APIs"},{"location":"mobile/kubeconfig/","text":"Kubeconfig You can also import a Kubeconfig file to add a new cluster to the kubenav app. Value Description Kubeconfig The content of your Kubeconfig file. You can copy and paste the content of the file into this Input field or you can select the file via the Select Kubeconfig button. Make sure that your Kubeconfig file does not contains paths to the certificate. Instead it should contain the base64 encoded certificate. For example: When your Kubeconfig file has a field certificate-authority with the path to a certificate, you have to replace this field with certificate-authority-data and the base64 encoded value of the certificate. Attention If you want to select your Kubeconfig via the file dialog ensure that the filename has a .yaml or .yml extension. Attention Make sure that the Kubeconfig file only contains clusters and users, which are not using a Cloud Provider or OIDC for the cluster access. The import for such Kubeconfig files will fail. Please use one of the available Cloud Providers to import such clusters.","title":"Kubeconfig"},{"location":"mobile/kubeconfig/#kubeconfig","text":"You can also import a Kubeconfig file to add a new cluster to the kubenav app. Value Description Kubeconfig The content of your Kubeconfig file. You can copy and paste the content of the file into this Input field or you can select the file via the Select Kubeconfig button. Make sure that your Kubeconfig file does not contains paths to the certificate. Instead it should contain the base64 encoded certificate. For example: When your Kubeconfig file has a field certificate-authority with the path to a certificate, you have to replace this field with certificate-authority-data and the base64 encoded value of the certificate. Attention If you want to select your Kubeconfig via the file dialog ensure that the filename has a .yaml or .yml extension. Attention Make sure that the Kubeconfig file only contains clusters and users, which are not using a Cloud Provider or OIDC for the cluster access. The import for such Kubeconfig files will fail. Please use one of the available Cloud Providers to import such clusters.","title":"Kubeconfig"},{"location":"mobile/manual/","text":"Manual This method can be used, when you want to manually configure each cluster. Value Description Name The name of the cluster, how it will be displayed in kubenav. Server The URL of the Kubernetes API server. Certificate Authority Data The certificate of the Kubernetes API server. This can be the base64 encoded value or the plain certificate. Insecure Skip TLS Verify If you haven't a certificate for the server, you can enabled the insecure mode, to skip the TLS verification. Client Certificate Data The client certificate. This can be the base64 encoded value or the plain certificate. Client Key Data The client key. This can be the base64 encoded value or the plain key. Token The access token for the Kubernetes API server. Username When you are using basic authentication you can use the username and password field. Password When you are using basic authentication you can use the username and password field. Use a Service Account If you haven't a Kubeconfig file which is compatible with kubenav or if your cloud provider isn't supported you can create a Service Account and use these credentials for the authentication. In the first step you have to create a ServiceAccount , ClusterRole and ClusterRoleBinding . In the following example we create the required resources in a new Namespace named kubenav : cat <<EOF | kubectl apply -f - --- apiVersion: v1 kind: Namespace metadata: name: kubenav --- apiVersion: v1 kind: ServiceAccount metadata: name: kubenav namespace: kubenav --- apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: kubenav namespace: kubenav rules: - apiGroups: [\"*\"] resources: [\"*\"] verbs: [\"*\"] --- apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: kubenav namespace: kubenav roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: kubenav subjects: - kind: ServiceAccount name: kubenav namespace: kubenav EOF Now we have to use the created secret, which is used by the Service Account. To get the name of the secret run the following command: export SECRET_NAME=$(kubectl get sa --namespace kubenav kubenav -o=jsonpath='{.secrets[*].name}') To get the certificate and access token to authenticate against the Kubernetes API we can run the following: kubectl get secret $SECRET_NAME -o=jsonpath='{.data.ca\\.crt}' | base64 --decode kubectl get secret $SECRET_NAME -o=jsonpath='{.data.token}' | base64 --decode The output from the first command can now be used for the Certificate Authority Data field and the output from the second command for the Token field. Attention The specified RBAC rules from the example provide full cluster access wihtout any restrictions. More information can be found in the Kubernets documentation: Using RBAC Authorization .","title":"Manual"},{"location":"mobile/manual/#manual","text":"This method can be used, when you want to manually configure each cluster. Value Description Name The name of the cluster, how it will be displayed in kubenav. Server The URL of the Kubernetes API server. Certificate Authority Data The certificate of the Kubernetes API server. This can be the base64 encoded value or the plain certificate. Insecure Skip TLS Verify If you haven't a certificate for the server, you can enabled the insecure mode, to skip the TLS verification. Client Certificate Data The client certificate. This can be the base64 encoded value or the plain certificate. Client Key Data The client key. This can be the base64 encoded value or the plain key. Token The access token for the Kubernetes API server. Username When you are using basic authentication you can use the username and password field. Password When you are using basic authentication you can use the username and password field.","title":"Manual"},{"location":"mobile/manual/#use-a-service-account","text":"If you haven't a Kubeconfig file which is compatible with kubenav or if your cloud provider isn't supported you can create a Service Account and use these credentials for the authentication. In the first step you have to create a ServiceAccount , ClusterRole and ClusterRoleBinding . In the following example we create the required resources in a new Namespace named kubenav : cat <<EOF | kubectl apply -f - --- apiVersion: v1 kind: Namespace metadata: name: kubenav --- apiVersion: v1 kind: ServiceAccount metadata: name: kubenav namespace: kubenav --- apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRole metadata: name: kubenav namespace: kubenav rules: - apiGroups: [\"*\"] resources: [\"*\"] verbs: [\"*\"] --- apiVersion: rbac.authorization.k8s.io/v1 kind: ClusterRoleBinding metadata: name: kubenav namespace: kubenav roleRef: apiGroup: rbac.authorization.k8s.io kind: ClusterRole name: kubenav subjects: - kind: ServiceAccount name: kubenav namespace: kubenav EOF Now we have to use the created secret, which is used by the Service Account. To get the name of the secret run the following command: export SECRET_NAME=$(kubectl get sa --namespace kubenav kubenav -o=jsonpath='{.secrets[*].name}') To get the certificate and access token to authenticate against the Kubernetes API we can run the following: kubectl get secret $SECRET_NAME -o=jsonpath='{.data.ca\\.crt}' | base64 --decode kubectl get secret $SECRET_NAME -o=jsonpath='{.data.token}' | base64 --decode The output from the first command can now be used for the Certificate Authority Data field and the output from the second command for the Token field. Attention The specified RBAC rules from the example provide full cluster access wihtout any restrictions. More information can be found in the Kubernets documentation: Using RBAC Authorization .","title":"Use a Service Account"},{"location":"mobile/microsoft-azure/","text":"Microsoft Azure To import your AKS clusters from Microsoft Azure your have to provide some credentials. The instructions on how to get/create these credentials can be found in the following. Value Description Subscription ID A unique alphanumeric string that identifies your Azure subscription. Client ID Client ID for your created Application. Client Secret Client Secret for your created Application. Tenant ID A unique id for your application which can be created via the Azure Active Directory. Resource Group Name The name of the resource group, where your AKS clusters were created. Admin Credentials When you activate this toggle kubenav will download the Kubeconfig file with the admin credentials of your user. Microsoft Azure: Creating App Credentials Login to the Microsoft Azure Portal , you need the following information to use the Azure integration for kubenav: Subscription ID Client ID Client Secret Tenant ID Resource Group Name To get a Client ID, Client Secret and Tenant ID, you have to create an App registration , in the Azure Active Directory . For this go to Azure Active Directory , App registrations and create a New registration . You do not need to provide a Redirect URI. After the creation note download the Application (client) ID and Directory (tenant) ID . Then for this App registration go to Certificates & secrets and create a new Client secret . Then for this App registration go to Manifest and set \"oAuth2AllowImplicitFlow\": true . Then save the changed manifest. Next you have to give the new App registration permissions to manage the above resources. For this go to Subscriptions , choose the subscription that you want to use with kubenav, take a note of the Subscription ID and then go to Access control (IAM) in your subscription. There add a new Role assignment between the role Contributor and the Azure AD user, group or service principal that you just created.","title":"Microsoft Azure"},{"location":"mobile/microsoft-azure/#microsoft-azure","text":"To import your AKS clusters from Microsoft Azure your have to provide some credentials. The instructions on how to get/create these credentials can be found in the following. Value Description Subscription ID A unique alphanumeric string that identifies your Azure subscription. Client ID Client ID for your created Application. Client Secret Client Secret for your created Application. Tenant ID A unique id for your application which can be created via the Azure Active Directory. Resource Group Name The name of the resource group, where your AKS clusters were created. Admin Credentials When you activate this toggle kubenav will download the Kubeconfig file with the admin credentials of your user.","title":"Microsoft Azure"},{"location":"mobile/microsoft-azure/#microsoft-azure-creating-app-credentials","text":"Login to the Microsoft Azure Portal , you need the following information to use the Azure integration for kubenav: Subscription ID Client ID Client Secret Tenant ID Resource Group Name To get a Client ID, Client Secret and Tenant ID, you have to create an App registration , in the Azure Active Directory . For this go to Azure Active Directory , App registrations and create a New registration . You do not need to provide a Redirect URI. After the creation note download the Application (client) ID and Directory (tenant) ID . Then for this App registration go to Certificates & secrets and create a new Client secret . Then for this App registration go to Manifest and set \"oAuth2AllowImplicitFlow\": true . Then save the changed manifest. Next you have to give the new App registration permissions to manage the above resources. For this go to Subscriptions , choose the subscription that you want to use with kubenav, take a note of the Subscription ID and then go to Access control (IAM) in your subscription. There add a new Role assignment between the role Contributor and the Azure AD user, group or service principal that you just created.","title":"Microsoft Azure: Creating App Credentials"},{"location":"mobile/oidc/","text":"OIDC If you are using an OIDC provider to manage the access to your Kubernetes cluster, you can configure this in the OIDC Provider section within the Add Clusters modal: Value Description Discovery URL The url for your OIDC provider. Client ID A valid client id for your OIDC provider. Client Secret A valid client secret for your OIDC provider. Certificate Authority If your OIDC provider uses a self signed certificate, you must provide this certificate. This field is optional for OIDC providers without a self signed certificate. Refresh Token You can provide a valid refresh token to skip the login process. This field is optional. If the field isn't provided you will be redirected to your OIDC provider to get a refresh token. Attention You must allow https://kubenav.io/oidc.html as a valid redirect url in the settings of your OIDC provider. When the login process within your OIDC provider is finished, you have to provide the details of your Kubernetes cluster: Value Description Name The name of the cluster, how it will be displayed in kubenav. Server The URL of the Kubernetes API server. Certificate Authority Data The certificate of the Kubernetes API server. This can be the base64 encoded value or the plain certificate. Insecure Skip TLS Verify If you haven't a certificate for the server, you can enabled the insecure mode, to skip the TLS verification.","title":"OIDC"},{"location":"mobile/oidc/#oidc","text":"If you are using an OIDC provider to manage the access to your Kubernetes cluster, you can configure this in the OIDC Provider section within the Add Clusters modal: Value Description Discovery URL The url for your OIDC provider. Client ID A valid client id for your OIDC provider. Client Secret A valid client secret for your OIDC provider. Certificate Authority If your OIDC provider uses a self signed certificate, you must provide this certificate. This field is optional for OIDC providers without a self signed certificate. Refresh Token You can provide a valid refresh token to skip the login process. This field is optional. If the field isn't provided you will be redirected to your OIDC provider to get a refresh token. Attention You must allow https://kubenav.io/oidc.html as a valid redirect url in the settings of your OIDC provider. When the login process within your OIDC provider is finished, you have to provide the details of your Kubernetes cluster: Value Description Name The name of the cluster, how it will be displayed in kubenav. Server The URL of the Kubernetes API server. Certificate Authority Data The certificate of the Kubernetes API server. This can be the base64 encoded value or the plain certificate. Insecure Skip TLS Verify If you haven't a certificate for the server, you can enabled the insecure mode, to skip the TLS verification.","title":"OIDC"},{"location":"mobile/settings/","text":"Settings kubenav provides multiple settings, to customize the look and usage of the app. General Setting Description Values Default Theme Set the theme which should be used for kubenav. System , Dark , Light System Authentication Enable authentication via fingerprint or face recognation. true , false false Request Timeout (in seconds) The maximum time in seconds for a request. 10 - 120 60 Terminal Font Size (in px) The font size for the terminal. 8 - 48 12 Terminal Scrollback (in lines) The maximum number of lines to scrollback in the terminal. 1000 - 50000 10000 Enable Pod Metrics Enables or disables the metrics for Pods in list views. true , false true Limit The maximum number of items which can be queried per request. 100 - 1000 100 Refresh Interval (in seconds) The interval in which the data of views is refreshed. 30 - 600 300 SSH Setting Description Default Port The port, which should be used for the SSH connection. 22 Private Key The private key, which should be used for the SSH connection. User The name of the user, which should be used for the SSH connection. Prometheus Setting Description Default Enabled Enables or disables the Prometheus plugin. false Namespace The namespace, where Prometheus is running. monitoring Selector The selector, which matches the Prometheus Pod. app=prometheus Port The port, where the Prometheus API is exposed. 9090 Username Username for Prometheus, when the Prometheus endpoint is protected via Basic Authentication. Password Password for Prometheus, when the Prometheus endpoint is protected via Basic Authentication. Dashboards Namespace The namespace, where kubenav should look for dashboards. kubenav Elasticsearch Setting Description Default Enabled Enables or disables the Elasticsearch plugin. false Namespace The namespace, where Elasticsearch is running. logging Selector The selector, which matches the Elasticsearch Pod. app=elasticsearch Port The port, where the Elasticsearch API is exposed. 9200 Username Username for Elasticsearch, when the Elasticsearch endpoint is protected via Basic Authentication. Password Password for Elasticsearch, when the Elasticsearch endpoint is protected via Basic Authentication. Jaeger Setting Description Default Enabled Enables or disables the Jaeger plugin. false Namespace The namespace, where Jaeger is running. tracing Selector The selector, which matches the Jaeger Pod. app=jaeger,app.kubernetes.io/component=query Port The port, where the Jaeger API is exposed. 16686 Username Username for Jaeger, when the Jaeger endpoint is protected via Basic Authentication. Password Password for Jaeger, when the Jaeger endpoint is protected via Basic Authentication. Query Base Path The base path for all Jaeger Query HTTP routes. This must be the same as the --query.base-path command line parameter or the QUERY_BASE_PATH environment variable. Proxy Setting Description Enabled When the proxy setting is enabled, all requests are using the configured proxy. Address The address of the proxy.","title":"Settings"},{"location":"mobile/settings/#settings","text":"kubenav provides multiple settings, to customize the look and usage of the app.","title":"Settings"},{"location":"mobile/settings/#general","text":"Setting Description Values Default Theme Set the theme which should be used for kubenav. System , Dark , Light System Authentication Enable authentication via fingerprint or face recognation. true , false false Request Timeout (in seconds) The maximum time in seconds for a request. 10 - 120 60 Terminal Font Size (in px) The font size for the terminal. 8 - 48 12 Terminal Scrollback (in lines) The maximum number of lines to scrollback in the terminal. 1000 - 50000 10000 Enable Pod Metrics Enables or disables the metrics for Pods in list views. true , false true Limit The maximum number of items which can be queried per request. 100 - 1000 100 Refresh Interval (in seconds) The interval in which the data of views is refreshed. 30 - 600 300","title":"General"},{"location":"mobile/settings/#ssh","text":"Setting Description Default Port The port, which should be used for the SSH connection. 22 Private Key The private key, which should be used for the SSH connection. User The name of the user, which should be used for the SSH connection.","title":"SSH"},{"location":"mobile/settings/#prometheus","text":"Setting Description Default Enabled Enables or disables the Prometheus plugin. false Namespace The namespace, where Prometheus is running. monitoring Selector The selector, which matches the Prometheus Pod. app=prometheus Port The port, where the Prometheus API is exposed. 9090 Username Username for Prometheus, when the Prometheus endpoint is protected via Basic Authentication. Password Password for Prometheus, when the Prometheus endpoint is protected via Basic Authentication. Dashboards Namespace The namespace, where kubenav should look for dashboards. kubenav","title":"Prometheus"},{"location":"mobile/settings/#elasticsearch","text":"Setting Description Default Enabled Enables or disables the Elasticsearch plugin. false Namespace The namespace, where Elasticsearch is running. logging Selector The selector, which matches the Elasticsearch Pod. app=elasticsearch Port The port, where the Elasticsearch API is exposed. 9200 Username Username for Elasticsearch, when the Elasticsearch endpoint is protected via Basic Authentication. Password Password for Elasticsearch, when the Elasticsearch endpoint is protected via Basic Authentication.","title":"Elasticsearch"},{"location":"mobile/settings/#jaeger","text":"Setting Description Default Enabled Enables or disables the Jaeger plugin. false Namespace The namespace, where Jaeger is running. tracing Selector The selector, which matches the Jaeger Pod. app=jaeger,app.kubernetes.io/component=query Port The port, where the Jaeger API is exposed. 16686 Username Username for Jaeger, when the Jaeger endpoint is protected via Basic Authentication. Password Password for Jaeger, when the Jaeger endpoint is protected via Basic Authentication. Query Base Path The base path for all Jaeger Query HTTP routes. This must be the same as the --query.base-path command line parameter or the QUERY_BASE_PATH environment variable.","title":"Jaeger"},{"location":"mobile/settings/#proxy","text":"Setting Description Enabled When the proxy setting is enabled, all requests are using the configured proxy. Address The address of the proxy.","title":"Proxy"},{"location":"plugins/elasticsearch/","text":"Elasticsearch The Elasticsearch plugin is used to query Elasticsearch for logs of your workloads. The plugin can be enabled in the Settings for the mobile and desktop version. To use the plugin in the web version you have to set the --plugin.elasticsearch.enabled flag. A detailed explanation of the each setting and the required command-line flags can be found in the respective documentation: Mobile Desktop Web Query String Syntax The Elasticsearch plugins uses the query string syntax for filtering log lines. Field Names You can specify fields to search in the query syntax: where the status field contains active status:active where the title field contains quick or brown title:(quick OR brown) where the author field contains the exact phrase \"john smith\" author:\"John Smith\" where the first name field contains Alice (note how we need to escape the space with a backslash) first\\ name:Alice where any of the fields book.title , book.content or book.date contains quick or brown (note how we need to escape the * with a backslash): book.\\*:(quick OR brown) where the field title has any non-null value: _exists_:title Wildcards Wildcard searches can be run on individual terms, using ? to replace a single character, and * to replace zero or more characters: qu?ck bro* Regular Expressions Regular expression patterns can be embedded in the query string by wrapping them in forward-slashes ( \"/\" ): name:/joh?n(ath[oa]n)/ Fuzziness We can search for terms that are similar to, but not exactly like our search terms, using the \"fuzzy\" operator: quikc~ brwn~ foks~ Ranges Ranges can be specified for date, numeric or string fields. Inclusive ranges are specified with square brackets [min TO max] and exclusive ranges with curly brackets {min TO max} . All days in 2012: date:[2012-01-01 TO 2012-12-31] Numbers 1..5 count:[1 TO 5] Tags between alpha and omega , excluding alpha and omega : tag:{alpha TO omega} Numbers from 10 upwards count:[10 TO *] Dates before 2012 date:{* TO 2012-01-01} Boolean operators By default, all terms are optional, as long as one term matches. A search for foo bar baz will find any document that contains one or more of foo or bar or baz . We have already discussed the default_operator above which allows you to force all terms to be required, but there are also boolean operators which can be used in the query string itself to provide more control. The preferred operators are + (this term must be present) and - (this term must not be present). All other terms are optional. For example, this query: quick brown +fox -news Grouping Multiple terms or clauses can be grouped together with parentheses, to form sub-queries: (quick OR brown) AND fox Date Math The Elasticsearch plugin uses date math to define the start and end time of a query. The expression starts with an anchor date, which can either be now , or a date string ending with || . This anchor date can optionally be followed by one or more maths expressions: +1h : Add one hour -1d : Subtract one day /d : Round down to the nearest day The supported time units differ from those supported by time-units for durations. The supported units are: y :: Years M :: Months w :: Weeks d :: Days h :: Hours H :: Hours m :: Minutes s :: Seconds Assuming now is 2001-01-01 12:00:00 , some examples are: now+1h :: now in milliseconds plus one hour. Resolves to: 2001-01-01 13:00:00 now-1h :: now in milliseconds minus one hour. Resolves to: 2001-01-01 11:00:00 now-1h/d :: now in milliseconds minus one hour, rounded down to UTC 00:00. Resolves to: 2001-01-01 00:00:00 2001.02.01\\|\\|+1M/d :: 2001-02-01 in milliseconds plus one month. Resolves to: 2001-03-01 00:00:00 Annotations You can add an annotation to your resources, to define Elasticsearch queries within these resources. The queries can be defined via the kubenav.io/elasticsearch-queries annotation. The annotation requires a JSON array, where each item in the array can use the following fields: Field Description Default Value title A title for the defined query. Required query Query to filter the Elasticsearch results in query string syntax. Required from Start time for the query. now-15m to End time for the query. now selectedFields Comma separated list of fields, which should be shown in the results. An annotation to get all logs for a Pod, can look as follows: apiVersion: v1 kind: Pod metadata: annotations: kubenav.io/elasticsearch-queries: '[{\"title\": \"All logs for the current Pod\", \"query\": \"kubernetes.namespace: $.metadata.namespace AND kubernetes.pod.name: $.metadata.name \", \"selectedFields\": \"kubernetes.labels.app,host.name\"}]' labels: app: kubenav name: kubenav-58d7f97f9f-462xd namespace: kubenav spec: You can use the $. operator, to select a field from the resource manifest, for example $.metadata.namespace will be replaced with the Namespace of the resource. Attention When you are using the $. operator, the replacing will only work, when the term is starting and ending with a space .","title":"Elasticsearch"},{"location":"plugins/elasticsearch/#elasticsearch","text":"The Elasticsearch plugin is used to query Elasticsearch for logs of your workloads. The plugin can be enabled in the Settings for the mobile and desktop version. To use the plugin in the web version you have to set the --plugin.elasticsearch.enabled flag. A detailed explanation of the each setting and the required command-line flags can be found in the respective documentation: Mobile Desktop Web","title":"Elasticsearch"},{"location":"plugins/elasticsearch/#query-string-syntax","text":"The Elasticsearch plugins uses the query string syntax for filtering log lines.","title":"Query String Syntax"},{"location":"plugins/elasticsearch/#field-names","text":"You can specify fields to search in the query syntax: where the status field contains active status:active where the title field contains quick or brown title:(quick OR brown) where the author field contains the exact phrase \"john smith\" author:\"John Smith\" where the first name field contains Alice (note how we need to escape the space with a backslash) first\\ name:Alice where any of the fields book.title , book.content or book.date contains quick or brown (note how we need to escape the * with a backslash): book.\\*:(quick OR brown) where the field title has any non-null value: _exists_:title","title":"Field Names"},{"location":"plugins/elasticsearch/#wildcards","text":"Wildcard searches can be run on individual terms, using ? to replace a single character, and * to replace zero or more characters: qu?ck bro*","title":"Wildcards"},{"location":"plugins/elasticsearch/#regular-expressions","text":"Regular expression patterns can be embedded in the query string by wrapping them in forward-slashes ( \"/\" ): name:/joh?n(ath[oa]n)/","title":"Regular Expressions"},{"location":"plugins/elasticsearch/#fuzziness","text":"We can search for terms that are similar to, but not exactly like our search terms, using the \"fuzzy\" operator: quikc~ brwn~ foks~","title":"Fuzziness"},{"location":"plugins/elasticsearch/#ranges","text":"Ranges can be specified for date, numeric or string fields. Inclusive ranges are specified with square brackets [min TO max] and exclusive ranges with curly brackets {min TO max} . All days in 2012: date:[2012-01-01 TO 2012-12-31] Numbers 1..5 count:[1 TO 5] Tags between alpha and omega , excluding alpha and omega : tag:{alpha TO omega} Numbers from 10 upwards count:[10 TO *] Dates before 2012 date:{* TO 2012-01-01}","title":"Ranges"},{"location":"plugins/elasticsearch/#boolean-operators","text":"By default, all terms are optional, as long as one term matches. A search for foo bar baz will find any document that contains one or more of foo or bar or baz . We have already discussed the default_operator above which allows you to force all terms to be required, but there are also boolean operators which can be used in the query string itself to provide more control. The preferred operators are + (this term must be present) and - (this term must not be present). All other terms are optional. For example, this query: quick brown +fox -news","title":"Boolean operators"},{"location":"plugins/elasticsearch/#grouping","text":"Multiple terms or clauses can be grouped together with parentheses, to form sub-queries: (quick OR brown) AND fox","title":"Grouping"},{"location":"plugins/elasticsearch/#date-math","text":"The Elasticsearch plugin uses date math to define the start and end time of a query. The expression starts with an anchor date, which can either be now , or a date string ending with || . This anchor date can optionally be followed by one or more maths expressions: +1h : Add one hour -1d : Subtract one day /d : Round down to the nearest day The supported time units differ from those supported by time-units for durations. The supported units are: y :: Years M :: Months w :: Weeks d :: Days h :: Hours H :: Hours m :: Minutes s :: Seconds Assuming now is 2001-01-01 12:00:00 , some examples are: now+1h :: now in milliseconds plus one hour. Resolves to: 2001-01-01 13:00:00 now-1h :: now in milliseconds minus one hour. Resolves to: 2001-01-01 11:00:00 now-1h/d :: now in milliseconds minus one hour, rounded down to UTC 00:00. Resolves to: 2001-01-01 00:00:00 2001.02.01\\|\\|+1M/d :: 2001-02-01 in milliseconds plus one month. Resolves to: 2001-03-01 00:00:00","title":"Date Math"},{"location":"plugins/elasticsearch/#annotations","text":"You can add an annotation to your resources, to define Elasticsearch queries within these resources. The queries can be defined via the kubenav.io/elasticsearch-queries annotation. The annotation requires a JSON array, where each item in the array can use the following fields: Field Description Default Value title A title for the defined query. Required query Query to filter the Elasticsearch results in query string syntax. Required from Start time for the query. now-15m to End time for the query. now selectedFields Comma separated list of fields, which should be shown in the results. An annotation to get all logs for a Pod, can look as follows: apiVersion: v1 kind: Pod metadata: annotations: kubenav.io/elasticsearch-queries: '[{\"title\": \"All logs for the current Pod\", \"query\": \"kubernetes.namespace: $.metadata.namespace AND kubernetes.pod.name: $.metadata.name \", \"selectedFields\": \"kubernetes.labels.app,host.name\"}]' labels: app: kubenav name: kubenav-58d7f97f9f-462xd namespace: kubenav spec: You can use the $. operator, to select a field from the resource manifest, for example $.metadata.namespace will be replaced with the Namespace of the resource. Attention When you are using the $. operator, the replacing will only work, when the term is starting and ending with a space .","title":"Annotations"},{"location":"plugins/helm/","text":"Helm The Helm plugin doesn't require any configuration. It can be found in the Menu under Plugins . To use the Helm plugin, you need the permissions to view secrets, because Helm uses secrets as the default storage driver . Attention The Helm plugin doesn't support infinite scrolling to load the secrets. If you have a lot of Helm charts in one namespace, you can increase the Limit parameter in the settings.","title":"Helm"},{"location":"plugins/helm/#helm","text":"The Helm plugin doesn't require any configuration. It can be found in the Menu under Plugins . To use the Helm plugin, you need the permissions to view secrets, because Helm uses secrets as the default storage driver . Attention The Helm plugin doesn't support infinite scrolling to load the secrets. If you have a lot of Helm charts in one namespace, you can increase the Limit parameter in the settings.","title":"Helm"},{"location":"plugins/jaeger/","text":"Jaeger The Jaeger plugin is used to find traces from Jaeger within kubenav. The plugin allows you to connect your resources with Jaeger services. The plugin can be enabled in the Settings for the mobile and desktop version. To use the plugin in the web version you have to set the --plugin.jaeger.enabled flag. A detailed explanation of the each setting and the required command-line flags can be found in the respective documentation: Mobile Desktop Web Annotations You can add an annotation to your resources, to define Jaeger Traces within these resources. The traces can be defined via the kubenav.io/jaeger-traces annotation. The annotation requires a JSON array, where each item in the array can use the following fields: Field Description Default Value title A title for the defined trace. Required service Service to get traces for. Required operation The operation for which the traces should be retrieved. When this isn't provided traces are retrieved for all operations. tags Filter traces by tags, for example http.status_code=200 error=true lookback Time to lookback for traces. The value must be a valid Go duration ( ParseDuration ). 1h maxDuration Maximum duration for a trace, for example 100ms . minDuration Minimum duration for a trace, for example 100ms . limit Number of traces, which are returned. 20 An annotation to get all traces for a service named details.bookinfo , can look as follows: apiVersion: v1 kind: Pod metadata: annotations: kubenav.io/jaeger-traces: '[{\"title\": \"Traces for details.bookinfo\", \"service\": \"details.bookinfo\"}]' labels: app: bookinfo name: details-v1-1520924117-48z17 namespace: bookinfo spec:","title":"Jaeger"},{"location":"plugins/jaeger/#jaeger","text":"The Jaeger plugin is used to find traces from Jaeger within kubenav. The plugin allows you to connect your resources with Jaeger services. The plugin can be enabled in the Settings for the mobile and desktop version. To use the plugin in the web version you have to set the --plugin.jaeger.enabled flag. A detailed explanation of the each setting and the required command-line flags can be found in the respective documentation: Mobile Desktop Web","title":"Jaeger"},{"location":"plugins/jaeger/#annotations","text":"You can add an annotation to your resources, to define Jaeger Traces within these resources. The traces can be defined via the kubenav.io/jaeger-traces annotation. The annotation requires a JSON array, where each item in the array can use the following fields: Field Description Default Value title A title for the defined trace. Required service Service to get traces for. Required operation The operation for which the traces should be retrieved. When this isn't provided traces are retrieved for all operations. tags Filter traces by tags, for example http.status_code=200 error=true lookback Time to lookback for traces. The value must be a valid Go duration ( ParseDuration ). 1h maxDuration Maximum duration for a trace, for example 100ms . minDuration Minimum duration for a trace, for example 100ms . limit Number of traces, which are returned. 20 An annotation to get all traces for a service named details.bookinfo , can look as follows: apiVersion: v1 kind: Pod metadata: annotations: kubenav.io/jaeger-traces: '[{\"title\": \"Traces for details.bookinfo\", \"service\": \"details.bookinfo\"}]' labels: app: bookinfo name: details-v1-1520924117-48z17 namespace: bookinfo spec:","title":"Annotations"},{"location":"plugins/prometheus/","text":"Prometheus The Prometheus plugin is used to display additional Prometheus metrics for Nodes, Deployments, StatefulSets, Pods, etc. The plugin can be enabled in the Settings for the mobile and desktop version. To use the plugin in the web version you have to set the --plugin.prometheus.enabled flag. A detailed explanation of the each setting and the required command-line flags can be found in the respective documentation: Mobile Desktop Web Default Metrics The Prometheus plugin supports some out of the box metrics for Nodes, Deployments, StatefulSets, Pods, etc. These metrics are generated by the kube-state-metrics and the node_exporter , which must be installed by you. Dashboards kubenav supports custom dashboards via the Prometheus plugin. To create a dashboard you have to create a ConfigMap in the defined dashboards namespace and with a label kubenav.io/dashboard: \"true\" . --- apiVersion: v1 kind: ConfigMap metadata: # Name of the ConfigMap. The name is used as reference in the \"kubenav.io/prometheus-dashboards\" annotation. name: nginx-ingress-dashboard # Dashboards namespace, which is configured in the settings via \"Dashboards Namespace\" or via the \"--plugin.prometheus.dashboards-namespace\" command-line flag. namespace: kubenav labels: # Required label, so that kubenav can found the dashboard. kubenav.io/prometheus-dashboard: \"true\" data: # Title of the dashboard. title: \"NGINX Ingress Controller\" # Description of the dashboard. description: \"Dashboard for NGINX Ingress Controller Metrics\" # Array of variables. variables: | [ { \"name\": \"Namespace\", \"label\": \"controller_namespace\", \"query\": \"nginx_ingress_controller_config_hash\", \"allowAll\": true }, { \"name\": \"ControllerClass\", \"label\": \"controller_class\", \"query\": \"nginx_ingress_controller_config_hash{namespace=~\\\"{{ .Namespace }}\\\"}\", \"allowAll\": true }, { \"name\": \"Controller\", \"label\": \"controller_pod\", \"query\": \"nginx_ingress_controller_config_hash{namespace=~\\\"{{ .Namespace }}\\\",controller_class=~\\\"{{ .ControllerClass }}\\\"}\", \"allowAll\": true }, { \"name\": \"Ingress\", \"label\": \"ingress\", \"query\": \"nginx_ingress_controller_requests{namespace=~\\\"{{ .Namespace }}\\\",controller_class=~\\\"{{ .ControllerClass }}\\\", controller_pod=~\\\"{{ .Controller }}\\\"}\", \"allowAll\": true } ] # Array of charts. charts: | [ { \"title\": \"Controller Request Volume\", \"unit\": \"ops\", \"size\": { \"xs\": \"12\", \"sm\": \"12\", \"md\": \"4\", \"lg\": \"4\", \"xl\": \"4\" }, \"type\": \"singlestat\", \"queries\": [ { \"label\": \"Request Volume\", \"query\": \"round(sum(irate(nginx_ingress_controller_requests{controller_pod=~\\\"{{ .Controller }}\\\",controller_class=~\\\"{{ .ControllerClass }}\\\",namespace=~\\\"{{ .Namespace }}\\\"}[2m])), 0.001)\" } ] }, { \"title\": \"Controller Connections\", \"unit\": \"\", \"size\": { \"xs\": \"12\", \"sm\": \"12\", \"md\": \"4\", \"lg\": \"4\", \"xl\": \"4\" }, \"type\": \"singlestat\", \"queries\": [ { \"label\": \"Controller Connections\", \"query\": \"sum(avg_over_time(nginx_ingress_controller_nginx_process_connections{controller_pod=~\\\"{{ .Controller }}\\\",controller_class=~\\\"{{ .ControllerClass }}\\\",namespace=~\\\"{{ .Namespace }}\\\"}[2m]))\" } ] }, { \"title\": \"Controller Success Rate\", \"unit\": \"%\", \"size\": { \"xs\": \"12\", \"sm\": \"12\", \"md\": \"4\", \"lg\": \"4\", \"xl\": \"4\" }, \"type\": \"singlestat\", \"queries\": [ { \"label\": \"Controller Success Rate\", \"query\": \"sum(rate(nginx_ingress_controller_requests{controller_pod=~\\\"{{ .Controller }}\\\",controller_class=~\\\"{{ .ControllerClass }}\\\",namespace=~\\\"{{ .Namespace }}\\\",status!~\\\"[4-5].*\\\"}[2m])) / sum(rate(nginx_ingress_controller_requests{controller_pod=~\\\"{{ .Controller }}\\\",controller_class=~\\\"{{ .ControllerClass }}\\\",namespace=~\\\"{{ .Namespace }}\\\"}[2m])) * 100\" } ] }, { \"title\": \"Ingress Request Volume\", \"unit\": \"reqps\", \"size\": { \"xs\": \"12\", \"sm\": \"12\", \"md\": \"12\", \"lg\": \"6\", \"xl\": \"6\" }, \"type\": \"area\", \"queries\": [ { \"label\": \"{{ .ingress }}\", \"query\": \"round(sum(irate(nginx_ingress_controller_requests{controller_pod=~\\\"{{ .Controller }}\\\",controller_class=~\\\"{{ .ControllerClass }}\\\",namespace=~\\\"{{ .Namespace }}\\\",ingress=~\\\"{{ .Ingress }}\\\"}[2m])) by (ingress), 0.001)\" } ] }, { \"title\": \"Ingress Success Rate\", \"unit\": \"%\", \"size\": { \"xs\": \"12\", \"sm\": \"12\", \"md\": \"12\", \"lg\": \"6\", \"xl\": \"6\" }, \"type\": \"area\", \"queries\": [ { \"label\": \"{{ .ingress }}\", \"query\": \"sum(rate(nginx_ingress_controller_requests{controller_pod=~\\\"{{ .Controller }}\\\",controller_class=~\\\"{{ .ControllerClass }}\\\",namespace=~\\\"{{ .Namespace }}\\\",ingress=~\\\"{{ .Ingress }}\\\",status!~\\\"[4-5].*\\\"}[2m])) by (ingress) / sum(rate(nginx_ingress_controller_requests{controller_pod=~\\\"{{ .Controller }}\\\",controller_class=~\\\"{{ .ControllerClass }}\\\",namespace=~\\\"{{ .Namespace }}\\\",ingress=~\\\"{{ .Ingress }}\\\"}[2m])) by (ingress) * 100\" } ] }, { \"title\": \"Network I/O Pressure\", \"unit\": \"MB/s\", \"size\": { \"xs\": \"12\", \"sm\": \"12\", \"md\": \"12\", \"lg\": \"4\", \"xl\": \"4\" }, \"type\": \"area\", \"queries\": [ { \"label\": \"Received\", \"query\": \"sum (irate (nginx_ingress_controller_request_size_sum{controller_pod=~\\\"{{ .Controller }}\\\",controller_class=~\\\"{{ .ControllerClass }}\\\",namespace=~\\\"{{ .Namespace }}\\\"}[2m])) / 1024 / 1024\" }, { \"label\": \"Sent\", \"query\": \"- sum (irate (nginx_ingress_controller_response_size_sum{controller_pod=~\\\"{{ .Controller }}\\\",controller_class=~\\\"{{ .ControllerClass }}\\\",namespace=~\\\"{{ .Namespace }}\\\"}[2m])) / 1024 / 1024\" } ] }, { \"title\": \"Average Memory Usage\", \"unit\": \"MiB\", \"size\": { \"xs\": \"12\", \"sm\": \"12\", \"md\": \"12\", \"lg\": \"4\", \"xl\": \"4\" }, \"type\": \"area\", \"queries\": [ { \"label\": \"NGINX\", \"query\": \"avg(nginx_ingress_controller_nginx_process_resident_memory_bytes{controller_pod=~\\\"{{ .Controller }}\\\",controller_class=~\\\"{{ .ControllerClass }}\\\",namespace=~\\\"{{ .Namespace }}\\\"}) / 1024 / 1024\" } ] }, { \"title\": \"Average CPU Usage\", \"unit\": \"Cores\", \"size\": { \"xs\": \"12\", \"sm\": \"12\", \"md\": \"12\", \"lg\": \"4\", \"xl\": \"4\" }, \"type\": \"area\", \"queries\": [ { \"label\": \"NGINX\", \"query\": \"sum (rate (nginx_ingress_controller_nginx_process_cpu_seconds_total{controller_pod=~\\\"{{ .Controller }}\\\",controller_class=~\\\"{{ .ControllerClass }}\\\",namespace=~\\\"{{ .Namespace }}\\\"}[2m]))\" } ] }, { \"title\": \"Ingress Certificate Expiry\", \"unit\": \"Days\", \"size\": { \"xs\": \"12\", \"sm\": \"12\", \"md\": \"12\", \"lg\": \"12\", \"xl\": \"12\" }, \"type\": \"area\", \"queries\": [ { \"label\": \"{{ .host }}\", \"query\": \"(avg(nginx_ingress_controller_ssl_expire_time_seconds{namespace=~\\\"{{ .Namespace }}\\\"}) by (host) - time()) / 60 / 60 / 24\" } ] } ] Variables Field Description name The name of the variable. The variable can then be used in other queries via {{ .Name }} . label Label from the returned Prometheus data, which should be used to fill the values of the variable. query Prometheus query, which should be used to get the values for the variable. allowAll Allows that the variable can have all values, which were returned from the query. Must be true or false . Charts Field Description title Title for the chart. unit Unit for the Y-Axis. size Size defines the size of the chart in a 12 column grid layout. The size object should contain the following properties: xs , sm , md , lg and xl type The type of the chart. This must be singlestat or area , other types are currently not supported. queries An array of queries, which are used for the chart. Each query must contain a label and a query . Annotations You can also add a reference to a dashboard within a resource. For that you have to add the kubenav.io/prometheus-dashboards annotation to the resource. The value is a comma seperated list of the ConfigMap names of the dashboards plus an optional query parameter. For example to add the NGINX Ingress Controller dashboard to an Ingress, the resource has to look as follows: apiVersion: extensions/v1beta1 kind: Ingress metadata: annotations: # Add the NGINX Ingress Controller and NGINX Ingress Controller: Request Handling Performance dashboard to the Ingress. # Set the Ingress variable to kubenav, so that the Ingress is selected in the dashboard. # The second dashboard uses the name of the Ingress as value for the Ingress variable. kubenav.io/prometheus-dashboards: nginx-ingress-dashboard?Ingress=kubenav,nginx-ingress-request-handling-performance-dashboard?Ingress=$.metadata.name kubernetes.io/ingress.class: nginx name: kubenav namespace: kubenav spec: rules: - host: dashboard.kubenav.io http: paths: - backend: serviceName: kubenav servicePort: http path: / Examples In the kubenav/deploy repository you can find some example dashboards, which are ready to use. blackbox-exporter-dashboard.yaml : Dashboard for Blackbox Exporter cert-manager-dashboard.yaml : Dashboard for cert-manager elasticsearch-dashboard.yaml : Dashboarf for Elasticsearch Exporter filebeat-dashboard.yaml : Dashboard for Filebeat go-dashboard.yaml : Dashboard for Go jaeger-dashboard.yaml : Dashboard for Jaeger jetty-dashboard.yaml : Dashboard for Java jvm-dashboard.yaml : Dashboard for Java mongodb-overview-dashboard.yaml : Overview dashboard for MongoDB Exporter mongodb-replicaset-dashboard.yaml : Replica Set dashboard for MongoDB Exporter mongodb-wiredtiger-dashboard.yaml : WiredTiger dashboard for MongoDB Exporter nats-dashboard.yaml : Dashboard for NATS nginx-ingress-dashboard.yaml : Dashboard for NGINX Ingress Controller nginx-ingress-request-handling-performance-dashboard.yaml : Performance dashboard for NGINX Ingress Controller node-exporter-dashboard.yaml : Dashboard for Node Exporter nodejs-dashboard.yaml : Dashboard for Node.js prometheus-dashboard.yaml : Dashboard for Prometheus redis-dashboard.yaml : Dashboard for Redis redis-sentinel-dashboard.yaml : Dashboard for Redis Sentinel reloader-dashboard.yaml : Dashboard for Reloader strimzi-kafka-dashboard.yaml : Dashboard for Strimzi strimzi-kafka-exporter-dashboard.yaml : Dashboard for Strimzi strimzi-operators-dashboard.yaml : Dashboard for Strimzi strimzi-zookeeper-dashboard.yaml : Dashboard for Strimzi thanos-compactor-dashboard.yaml : Dashboard for Thanos Compactor thanos-querier-dashboard.yaml : Dashboard for Thanos Querier thanos-receiver-dashboard.yaml : Dashboard for Thanos Receiver thanos-store-dashboard.yaml : Dashboard for Thanos Store varnish-dashboard.yaml : Dashboard for Varnish Exporter","title":"Prometheus"},{"location":"plugins/prometheus/#prometheus","text":"The Prometheus plugin is used to display additional Prometheus metrics for Nodes, Deployments, StatefulSets, Pods, etc. The plugin can be enabled in the Settings for the mobile and desktop version. To use the plugin in the web version you have to set the --plugin.prometheus.enabled flag. A detailed explanation of the each setting and the required command-line flags can be found in the respective documentation: Mobile Desktop Web","title":"Prometheus"},{"location":"plugins/prometheus/#default-metrics","text":"The Prometheus plugin supports some out of the box metrics for Nodes, Deployments, StatefulSets, Pods, etc. These metrics are generated by the kube-state-metrics and the node_exporter , which must be installed by you.","title":"Default Metrics"},{"location":"plugins/prometheus/#dashboards","text":"kubenav supports custom dashboards via the Prometheus plugin. To create a dashboard you have to create a ConfigMap in the defined dashboards namespace and with a label kubenav.io/dashboard: \"true\" . --- apiVersion: v1 kind: ConfigMap metadata: # Name of the ConfigMap. The name is used as reference in the \"kubenav.io/prometheus-dashboards\" annotation. name: nginx-ingress-dashboard # Dashboards namespace, which is configured in the settings via \"Dashboards Namespace\" or via the \"--plugin.prometheus.dashboards-namespace\" command-line flag. namespace: kubenav labels: # Required label, so that kubenav can found the dashboard. kubenav.io/prometheus-dashboard: \"true\" data: # Title of the dashboard. title: \"NGINX Ingress Controller\" # Description of the dashboard. description: \"Dashboard for NGINX Ingress Controller Metrics\" # Array of variables. variables: | [ { \"name\": \"Namespace\", \"label\": \"controller_namespace\", \"query\": \"nginx_ingress_controller_config_hash\", \"allowAll\": true }, { \"name\": \"ControllerClass\", \"label\": \"controller_class\", \"query\": \"nginx_ingress_controller_config_hash{namespace=~\\\"{{ .Namespace }}\\\"}\", \"allowAll\": true }, { \"name\": \"Controller\", \"label\": \"controller_pod\", \"query\": \"nginx_ingress_controller_config_hash{namespace=~\\\"{{ .Namespace }}\\\",controller_class=~\\\"{{ .ControllerClass }}\\\"}\", \"allowAll\": true }, { \"name\": \"Ingress\", \"label\": \"ingress\", \"query\": \"nginx_ingress_controller_requests{namespace=~\\\"{{ .Namespace }}\\\",controller_class=~\\\"{{ .ControllerClass }}\\\", controller_pod=~\\\"{{ .Controller }}\\\"}\", \"allowAll\": true } ] # Array of charts. charts: | [ { \"title\": \"Controller Request Volume\", \"unit\": \"ops\", \"size\": { \"xs\": \"12\", \"sm\": \"12\", \"md\": \"4\", \"lg\": \"4\", \"xl\": \"4\" }, \"type\": \"singlestat\", \"queries\": [ { \"label\": \"Request Volume\", \"query\": \"round(sum(irate(nginx_ingress_controller_requests{controller_pod=~\\\"{{ .Controller }}\\\",controller_class=~\\\"{{ .ControllerClass }}\\\",namespace=~\\\"{{ .Namespace }}\\\"}[2m])), 0.001)\" } ] }, { \"title\": \"Controller Connections\", \"unit\": \"\", \"size\": { \"xs\": \"12\", \"sm\": \"12\", \"md\": \"4\", \"lg\": \"4\", \"xl\": \"4\" }, \"type\": \"singlestat\", \"queries\": [ { \"label\": \"Controller Connections\", \"query\": \"sum(avg_over_time(nginx_ingress_controller_nginx_process_connections{controller_pod=~\\\"{{ .Controller }}\\\",controller_class=~\\\"{{ .ControllerClass }}\\\",namespace=~\\\"{{ .Namespace }}\\\"}[2m]))\" } ] }, { \"title\": \"Controller Success Rate\", \"unit\": \"%\", \"size\": { \"xs\": \"12\", \"sm\": \"12\", \"md\": \"4\", \"lg\": \"4\", \"xl\": \"4\" }, \"type\": \"singlestat\", \"queries\": [ { \"label\": \"Controller Success Rate\", \"query\": \"sum(rate(nginx_ingress_controller_requests{controller_pod=~\\\"{{ .Controller }}\\\",controller_class=~\\\"{{ .ControllerClass }}\\\",namespace=~\\\"{{ .Namespace }}\\\",status!~\\\"[4-5].*\\\"}[2m])) / sum(rate(nginx_ingress_controller_requests{controller_pod=~\\\"{{ .Controller }}\\\",controller_class=~\\\"{{ .ControllerClass }}\\\",namespace=~\\\"{{ .Namespace }}\\\"}[2m])) * 100\" } ] }, { \"title\": \"Ingress Request Volume\", \"unit\": \"reqps\", \"size\": { \"xs\": \"12\", \"sm\": \"12\", \"md\": \"12\", \"lg\": \"6\", \"xl\": \"6\" }, \"type\": \"area\", \"queries\": [ { \"label\": \"{{ .ingress }}\", \"query\": \"round(sum(irate(nginx_ingress_controller_requests{controller_pod=~\\\"{{ .Controller }}\\\",controller_class=~\\\"{{ .ControllerClass }}\\\",namespace=~\\\"{{ .Namespace }}\\\",ingress=~\\\"{{ .Ingress }}\\\"}[2m])) by (ingress), 0.001)\" } ] }, { \"title\": \"Ingress Success Rate\", \"unit\": \"%\", \"size\": { \"xs\": \"12\", \"sm\": \"12\", \"md\": \"12\", \"lg\": \"6\", \"xl\": \"6\" }, \"type\": \"area\", \"queries\": [ { \"label\": \"{{ .ingress }}\", \"query\": \"sum(rate(nginx_ingress_controller_requests{controller_pod=~\\\"{{ .Controller }}\\\",controller_class=~\\\"{{ .ControllerClass }}\\\",namespace=~\\\"{{ .Namespace }}\\\",ingress=~\\\"{{ .Ingress }}\\\",status!~\\\"[4-5].*\\\"}[2m])) by (ingress) / sum(rate(nginx_ingress_controller_requests{controller_pod=~\\\"{{ .Controller }}\\\",controller_class=~\\\"{{ .ControllerClass }}\\\",namespace=~\\\"{{ .Namespace }}\\\",ingress=~\\\"{{ .Ingress }}\\\"}[2m])) by (ingress) * 100\" } ] }, { \"title\": \"Network I/O Pressure\", \"unit\": \"MB/s\", \"size\": { \"xs\": \"12\", \"sm\": \"12\", \"md\": \"12\", \"lg\": \"4\", \"xl\": \"4\" }, \"type\": \"area\", \"queries\": [ { \"label\": \"Received\", \"query\": \"sum (irate (nginx_ingress_controller_request_size_sum{controller_pod=~\\\"{{ .Controller }}\\\",controller_class=~\\\"{{ .ControllerClass }}\\\",namespace=~\\\"{{ .Namespace }}\\\"}[2m])) / 1024 / 1024\" }, { \"label\": \"Sent\", \"query\": \"- sum (irate (nginx_ingress_controller_response_size_sum{controller_pod=~\\\"{{ .Controller }}\\\",controller_class=~\\\"{{ .ControllerClass }}\\\",namespace=~\\\"{{ .Namespace }}\\\"}[2m])) / 1024 / 1024\" } ] }, { \"title\": \"Average Memory Usage\", \"unit\": \"MiB\", \"size\": { \"xs\": \"12\", \"sm\": \"12\", \"md\": \"12\", \"lg\": \"4\", \"xl\": \"4\" }, \"type\": \"area\", \"queries\": [ { \"label\": \"NGINX\", \"query\": \"avg(nginx_ingress_controller_nginx_process_resident_memory_bytes{controller_pod=~\\\"{{ .Controller }}\\\",controller_class=~\\\"{{ .ControllerClass }}\\\",namespace=~\\\"{{ .Namespace }}\\\"}) / 1024 / 1024\" } ] }, { \"title\": \"Average CPU Usage\", \"unit\": \"Cores\", \"size\": { \"xs\": \"12\", \"sm\": \"12\", \"md\": \"12\", \"lg\": \"4\", \"xl\": \"4\" }, \"type\": \"area\", \"queries\": [ { \"label\": \"NGINX\", \"query\": \"sum (rate (nginx_ingress_controller_nginx_process_cpu_seconds_total{controller_pod=~\\\"{{ .Controller }}\\\",controller_class=~\\\"{{ .ControllerClass }}\\\",namespace=~\\\"{{ .Namespace }}\\\"}[2m]))\" } ] }, { \"title\": \"Ingress Certificate Expiry\", \"unit\": \"Days\", \"size\": { \"xs\": \"12\", \"sm\": \"12\", \"md\": \"12\", \"lg\": \"12\", \"xl\": \"12\" }, \"type\": \"area\", \"queries\": [ { \"label\": \"{{ .host }}\", \"query\": \"(avg(nginx_ingress_controller_ssl_expire_time_seconds{namespace=~\\\"{{ .Namespace }}\\\"}) by (host) - time()) / 60 / 60 / 24\" } ] } ]","title":"Dashboards"},{"location":"plugins/prometheus/#variables","text":"Field Description name The name of the variable. The variable can then be used in other queries via {{ .Name }} . label Label from the returned Prometheus data, which should be used to fill the values of the variable. query Prometheus query, which should be used to get the values for the variable. allowAll Allows that the variable can have all values, which were returned from the query. Must be true or false .","title":"Variables"},{"location":"plugins/prometheus/#charts","text":"Field Description title Title for the chart. unit Unit for the Y-Axis. size Size defines the size of the chart in a 12 column grid layout. The size object should contain the following properties: xs , sm , md , lg and xl type The type of the chart. This must be singlestat or area , other types are currently not supported. queries An array of queries, which are used for the chart. Each query must contain a label and a query .","title":"Charts"},{"location":"plugins/prometheus/#annotations","text":"You can also add a reference to a dashboard within a resource. For that you have to add the kubenav.io/prometheus-dashboards annotation to the resource. The value is a comma seperated list of the ConfigMap names of the dashboards plus an optional query parameter. For example to add the NGINX Ingress Controller dashboard to an Ingress, the resource has to look as follows: apiVersion: extensions/v1beta1 kind: Ingress metadata: annotations: # Add the NGINX Ingress Controller and NGINX Ingress Controller: Request Handling Performance dashboard to the Ingress. # Set the Ingress variable to kubenav, so that the Ingress is selected in the dashboard. # The second dashboard uses the name of the Ingress as value for the Ingress variable. kubenav.io/prometheus-dashboards: nginx-ingress-dashboard?Ingress=kubenav,nginx-ingress-request-handling-performance-dashboard?Ingress=$.metadata.name kubernetes.io/ingress.class: nginx name: kubenav namespace: kubenav spec: rules: - host: dashboard.kubenav.io http: paths: - backend: serviceName: kubenav servicePort: http path: /","title":"Annotations"},{"location":"plugins/prometheus/#examples","text":"In the kubenav/deploy repository you can find some example dashboards, which are ready to use. blackbox-exporter-dashboard.yaml : Dashboard for Blackbox Exporter cert-manager-dashboard.yaml : Dashboard for cert-manager elasticsearch-dashboard.yaml : Dashboarf for Elasticsearch Exporter filebeat-dashboard.yaml : Dashboard for Filebeat go-dashboard.yaml : Dashboard for Go jaeger-dashboard.yaml : Dashboard for Jaeger jetty-dashboard.yaml : Dashboard for Java jvm-dashboard.yaml : Dashboard for Java mongodb-overview-dashboard.yaml : Overview dashboard for MongoDB Exporter mongodb-replicaset-dashboard.yaml : Replica Set dashboard for MongoDB Exporter mongodb-wiredtiger-dashboard.yaml : WiredTiger dashboard for MongoDB Exporter nats-dashboard.yaml : Dashboard for NATS nginx-ingress-dashboard.yaml : Dashboard for NGINX Ingress Controller nginx-ingress-request-handling-performance-dashboard.yaml : Performance dashboard for NGINX Ingress Controller node-exporter-dashboard.yaml : Dashboard for Node Exporter nodejs-dashboard.yaml : Dashboard for Node.js prometheus-dashboard.yaml : Dashboard for Prometheus redis-dashboard.yaml : Dashboard for Redis redis-sentinel-dashboard.yaml : Dashboard for Redis Sentinel reloader-dashboard.yaml : Dashboard for Reloader strimzi-kafka-dashboard.yaml : Dashboard for Strimzi strimzi-kafka-exporter-dashboard.yaml : Dashboard for Strimzi strimzi-operators-dashboard.yaml : Dashboard for Strimzi strimzi-zookeeper-dashboard.yaml : Dashboard for Strimzi thanos-compactor-dashboard.yaml : Dashboard for Thanos Compactor thanos-querier-dashboard.yaml : Dashboard for Thanos Querier thanos-receiver-dashboard.yaml : Dashboard for Thanos Receiver thanos-store-dashboard.yaml : Dashboard for Thanos Store varnish-dashboard.yaml : Dashboard for Varnish Exporter","title":"Examples"},{"location":"web/command-line-flags/","text":"Command-Line Flags The Docker image for kubenav supports the following command-line flags: kubenav - the navigator for your Kubernetes clusters right in your pocket. Usage: kubenav [flags] kubenav [command] Available Commands: help Help about any command version Print version information for kubenav. Flags: --debug Enable debug mode. --debug.ionic string Path to the Ionic app. (default \"build\") -h, --help help for kubenav --incluster Use the in cluster configuration. --kubeconfig string Optional Kubeconfig file. --plugin.elasticsearch.address string The address for Elasticsearch. --plugin.elasticsearch.enabled Enable the Elasticsearch plugin. --plugin.elasticsearch.password string The password for Elasticsearch. --plugin.elasticsearch.username string The username for Elasticsearch. --plugin.jaeger.address string The address for Jaeger. --plugin.jaeger.enabled Enable the Jaeger plugin. --plugin.jaeger.password string The password for Jaeger. --plugin.jaeger.username string The username for Jaeger. --plugin.prometheus.address string The address for Prometheus. --plugin.prometheus.dashboards-namespace string The namespace, where kubenav should look for dashboards. (default \"kubenav\") --plugin.prometheus.enabled Enable the Prometheus plugin. --plugin.prometheus.password string The password for Prometheus. --plugin.prometheus.username string The username for Prometheus. Use \"kubenav [command] --help\" for more information about a command. Environment Variables The following command-line flags can be replaced via environment variables: Command-Line Flag Environment Variable --plugin.elasticsearch.password KUBENAV_ELASTICSEARCH_PASSWORD --plugin.elasticsearch.username KUBENAV_ELASTICSEARCH_USERNAME --plugin.jaeger.password KUBENAV_JAEGER_PASSWORD --plugin.jaeger.username KUBENAV_JAEGER_USERNAME --plugin.prometheus.password KUBENAV_PROMETHEUS_PASSWORD --plugin.prometheus.username KUBENAV_PROMETHEUS_USERNAME","title":"Command-Line Flags"},{"location":"web/command-line-flags/#command-line-flags","text":"The Docker image for kubenav supports the following command-line flags: kubenav - the navigator for your Kubernetes clusters right in your pocket. Usage: kubenav [flags] kubenav [command] Available Commands: help Help about any command version Print version information for kubenav. Flags: --debug Enable debug mode. --debug.ionic string Path to the Ionic app. (default \"build\") -h, --help help for kubenav --incluster Use the in cluster configuration. --kubeconfig string Optional Kubeconfig file. --plugin.elasticsearch.address string The address for Elasticsearch. --plugin.elasticsearch.enabled Enable the Elasticsearch plugin. --plugin.elasticsearch.password string The password for Elasticsearch. --plugin.elasticsearch.username string The username for Elasticsearch. --plugin.jaeger.address string The address for Jaeger. --plugin.jaeger.enabled Enable the Jaeger plugin. --plugin.jaeger.password string The password for Jaeger. --plugin.jaeger.username string The username for Jaeger. --plugin.prometheus.address string The address for Prometheus. --plugin.prometheus.dashboards-namespace string The namespace, where kubenav should look for dashboards. (default \"kubenav\") --plugin.prometheus.enabled Enable the Prometheus plugin. --plugin.prometheus.password string The password for Prometheus. --plugin.prometheus.username string The username for Prometheus. Use \"kubenav [command] --help\" for more information about a command.","title":"Command-Line Flags"},{"location":"web/command-line-flags/#environment-variables","text":"The following command-line flags can be replaced via environment variables: Command-Line Flag Environment Variable --plugin.elasticsearch.password KUBENAV_ELASTICSEARCH_PASSWORD --plugin.elasticsearch.username KUBENAV_ELASTICSEARCH_USERNAME --plugin.jaeger.password KUBENAV_JAEGER_PASSWORD --plugin.jaeger.username KUBENAV_JAEGER_USERNAME --plugin.prometheus.password KUBENAV_PROMETHEUS_PASSWORD --plugin.prometheus.username KUBENAV_PROMETHEUS_USERNAME","title":"Environment Variables"},{"location":"web/getting-started/","text":"Getting started kubenav is not only available for desktop and mobile, it can also be deployed to your Kubernetes cluster. The following page shows how kubenav can be deployed using Kustomize or Helm . The manifests for Kustomize and the Helm Chart can be found in the kubenav/deploy repository. The Docker image is available at Docker Hub .","title":"Getting started"},{"location":"web/getting-started/#getting-started","text":"kubenav is not only available for desktop and mobile, it can also be deployed to your Kubernetes cluster. The following page shows how kubenav can be deployed using Kustomize or Helm . The manifests for Kustomize and the Helm Chart can be found in the kubenav/deploy repository. The Docker image is available at Docker Hub .","title":"Getting started"},{"location":"web/helm/","text":"Helm You can deploy kubenav into your Kubernetes cluster via Helm : helm repo add kubenav https://kubenav.github.io/helm-repository helm repo update kubectl create namespace kubenav helm upgrade --install --namespace kubenav kubenav kubenav/kubenav Values Value Description Default replicaCount Number of replicas which should be created. 1 image.repository The repository of the Docker image. kubenav/kubenav image.tag The tag of the Docker image which should be used. 3.7.0 image.pullPolicy The pull policy for the Docker image, IfNotPresent imagePullSecrets Secrets which can be used to pull the Docker image. [] nameOverride Expand the name of the chart. \"\" fullnameOverride Override the name of the app. \"\" deployment.mode Set the mode how kubenav should be deployed. This must be incluster or kubeconfig . incluster deployment.kubeconfig When the kubeconfig mode is used. This must be a base64 encoded Kubeconfig file. \"\" plugins.prometheus.enabled Enables the Prometheus plugin. false plugins.prometheus.address The address of Prometheus. http://prometheus.monitoring.svc.cluster.local:9090 plugins.prometheus.username The username for Prometheus. \"\" plugins.prometheus.password The password for Prometheus. \"\" plugins.prometheus.dashboardsNamespace The namespace which is used for Prometheus dashboards. kubenav plugins.elasticsearch.enabled Enables the Elasticsearch plugin. false plugins.elasticsearch.address The address of Elasticsearch. http://elasticsearch.logging.svc.cluster.local:9200 plugins.elasticsearch.username The username for Elasticsearch. \"\" plugins.elasticsearch.password The password for Elasticsearch. \"\" plugins.jaeger.enabled Enables the Jaeger plugin. false plugins.jaeger.address The address of Jaeger. http://jaeger-query.tracing.svc.cluster.local:16686 plugins.jaeger.username The username for Jaeger. \"\" plugins.jaeger.password The password for Jaeger. \"\" rbac.create Create the cluster role and cluster role binding. true rbac.name The name of the cluster role and cluster role binding, which should be created/used by kubenav. kubenav rbac.name The permissions which kubenav should have. This must be admin or viewer . admin serviceAccount.create Create the service account. true serviceAccount.annotations Additional annotations for the service account. true serviceAccount.name The name of the service account, which should be created/used by kubenav. kubenav podSecurityContext Security context for the kubenav pod. {} securityContext Security context for the kubenav container. {} service.type Type of the service which is created. ClusterIP service.port Port of the service which is created. 14122 ingress.enabled Create an ingress. false ingress.annotations Additional annotations for the ingress. {} ingress.hosts Hosts for the ingress. [] ingress.tls TLS configuration for the ingress. [] resources Set resources for the operator. {} nodeSelector Set a node selector. {} tolerations Set tolerations. [] affinity Set affinity. {} Contributing Each contribution to kubenav is welcome. If you make changes to the Helm chart you have to bump the version in the helm/Chart.yaml file. Then a new version of the Helm chart is automatically published when your PR is merged into the master branch. When you add a new value to the helm/values.yaml file, please also adjust the documentation .","title":"Helm"},{"location":"web/helm/#helm","text":"You can deploy kubenav into your Kubernetes cluster via Helm : helm repo add kubenav https://kubenav.github.io/helm-repository helm repo update kubectl create namespace kubenav helm upgrade --install --namespace kubenav kubenav kubenav/kubenav","title":"Helm"},{"location":"web/helm/#values","text":"Value Description Default replicaCount Number of replicas which should be created. 1 image.repository The repository of the Docker image. kubenav/kubenav image.tag The tag of the Docker image which should be used. 3.7.0 image.pullPolicy The pull policy for the Docker image, IfNotPresent imagePullSecrets Secrets which can be used to pull the Docker image. [] nameOverride Expand the name of the chart. \"\" fullnameOverride Override the name of the app. \"\" deployment.mode Set the mode how kubenav should be deployed. This must be incluster or kubeconfig . incluster deployment.kubeconfig When the kubeconfig mode is used. This must be a base64 encoded Kubeconfig file. \"\" plugins.prometheus.enabled Enables the Prometheus plugin. false plugins.prometheus.address The address of Prometheus. http://prometheus.monitoring.svc.cluster.local:9090 plugins.prometheus.username The username for Prometheus. \"\" plugins.prometheus.password The password for Prometheus. \"\" plugins.prometheus.dashboardsNamespace The namespace which is used for Prometheus dashboards. kubenav plugins.elasticsearch.enabled Enables the Elasticsearch plugin. false plugins.elasticsearch.address The address of Elasticsearch. http://elasticsearch.logging.svc.cluster.local:9200 plugins.elasticsearch.username The username for Elasticsearch. \"\" plugins.elasticsearch.password The password for Elasticsearch. \"\" plugins.jaeger.enabled Enables the Jaeger plugin. false plugins.jaeger.address The address of Jaeger. http://jaeger-query.tracing.svc.cluster.local:16686 plugins.jaeger.username The username for Jaeger. \"\" plugins.jaeger.password The password for Jaeger. \"\" rbac.create Create the cluster role and cluster role binding. true rbac.name The name of the cluster role and cluster role binding, which should be created/used by kubenav. kubenav rbac.name The permissions which kubenav should have. This must be admin or viewer . admin serviceAccount.create Create the service account. true serviceAccount.annotations Additional annotations for the service account. true serviceAccount.name The name of the service account, which should be created/used by kubenav. kubenav podSecurityContext Security context for the kubenav pod. {} securityContext Security context for the kubenav container. {} service.type Type of the service which is created. ClusterIP service.port Port of the service which is created. 14122 ingress.enabled Create an ingress. false ingress.annotations Additional annotations for the ingress. {} ingress.hosts Hosts for the ingress. [] ingress.tls TLS configuration for the ingress. [] resources Set resources for the operator. {} nodeSelector Set a node selector. {} tolerations Set tolerations. [] affinity Set affinity. {}","title":"Values"},{"location":"web/helm/#contributing","text":"Each contribution to kubenav is welcome. If you make changes to the Helm chart you have to bump the version in the helm/Chart.yaml file. Then a new version of the Helm chart is automatically published when your PR is merged into the master branch. When you add a new value to the helm/values.yaml file, please also adjust the documentation .","title":"Contributing"},{"location":"web/kustomize/","text":"Kustomize You can deploy kubenav into your Kubernetes cluster via Kustomize : kubectl apply --kustomize github.com/kubenav/deploy/kustomize To access kubenav run the following command: kubectl port-forward --namespace kubenav svc/kubenav 14122","title":"Kustomize"},{"location":"web/kustomize/#kustomize","text":"You can deploy kubenav into your Kubernetes cluster via Kustomize : kubectl apply --kustomize github.com/kubenav/deploy/kustomize To access kubenav run the following command: kubectl port-forward --namespace kubenav svc/kubenav 14122","title":"Kustomize"},{"location":"web/multi-cluster-access/","text":"Configure Access to Multiple Clusters Attention When kubenav runs inside a Kubernetes cluster with the --kubeconfig flag and the Prometheus plugin enabled ( --plugin.prometheus.enabled ) it will only use the Prometheus instance, which is running in the same cluster. Kustomize The deployment shown in the kubenav/deploy repository deploys kubenav with the --incluster flag. This means kubenav has only access to the cluster were it is deployed in. To deploy kubenav with access to multiple cluster you have to mount a Kubeconfig file into the kubenav container and add the --kubeconfig flag. The following example shows the changes you have to made to the deployment.yaml file to access multiple clusters from the same kubenav instance: spec: template: spec: containers: - name: kubenav args: - --kubeconfig=/kubenav/kubeconfig/kubeconfig volumeMounts: - name: kubeconfig mountPath: '/kubenav/kubeconfig' readOnly: true volumes: - name: kubeconfig secret: secretName: kubeconfig The above example mounts a secret named kubeconfig into the kubenav pod and makes use of the Kubeconfig via the --kubeconfig flag. The secret must look as follows: --- apiVersion: v1 kind: Secret metadata: name: kubeconfig data: kubeconfig: <REPLACE WITH YOUR BASE64 ENCODED KUBECONFIG> type: Opaque The value for the data.kubeconfig key can be created with cat ~/.kube/config | base64 . Helm You can choose this mode also with the Helm Chart, for that you have to set the deployment.mode value to kubeconfig and you have to provide your base64 encoded Kubeconfig via the deployment.kubeconfig value.","title":"Configure Access to Multiple Clusters"},{"location":"web/multi-cluster-access/#configure-access-to-multiple-clusters","text":"Attention When kubenav runs inside a Kubernetes cluster with the --kubeconfig flag and the Prometheus plugin enabled ( --plugin.prometheus.enabled ) it will only use the Prometheus instance, which is running in the same cluster.","title":"Configure Access to Multiple Clusters"},{"location":"web/multi-cluster-access/#kustomize","text":"The deployment shown in the kubenav/deploy repository deploys kubenav with the --incluster flag. This means kubenav has only access to the cluster were it is deployed in. To deploy kubenav with access to multiple cluster you have to mount a Kubeconfig file into the kubenav container and add the --kubeconfig flag. The following example shows the changes you have to made to the deployment.yaml file to access multiple clusters from the same kubenav instance: spec: template: spec: containers: - name: kubenav args: - --kubeconfig=/kubenav/kubeconfig/kubeconfig volumeMounts: - name: kubeconfig mountPath: '/kubenav/kubeconfig' readOnly: true volumes: - name: kubeconfig secret: secretName: kubeconfig The above example mounts a secret named kubeconfig into the kubenav pod and makes use of the Kubeconfig via the --kubeconfig flag. The secret must look as follows: --- apiVersion: v1 kind: Secret metadata: name: kubeconfig data: kubeconfig: <REPLACE WITH YOUR BASE64 ENCODED KUBECONFIG> type: Opaque The value for the data.kubeconfig key can be created with cat ~/.kube/config | base64 .","title":"Kustomize"},{"location":"web/multi-cluster-access/#helm","text":"You can choose this mode also with the Helm Chart, for that you have to set the deployment.mode value to kubeconfig and you have to provide your base64 encoded Kubeconfig via the deployment.kubeconfig value.","title":"Helm"},{"location":"web/settings/","text":"Settings kubenav provides multiple settings, to customize the look and usage of the app. General Setting Description Values Default Theme Set the theme which should be used for kubenav. System , Dark , Light System Request Timeout (in seconds) The maximum time in seconds for a request. 10 - 120 60 Terminal Font Size (in px) The font size for the terminal. 8 - 48 12 Terminal Scrollback (in lines) The maximum number of lines to scrollback in the terminal. 1000 - 50000 10000 Enable Pod Metrics Enables or disables the metrics for Pods in list views. true , false true Limit The maximum number of items which can be queried per request. 100 - 1000 100 Refresh Interval (in seconds) The interval in which the data of views is refreshed. 30 - 600 300 SSH Setting Description Default Port The port, which should be used for the SSH connection. 22 Private Key The private key, which should be used for the SSH connection. User The name of the user, which should be used for the SSH connection.","title":"Settings"},{"location":"web/settings/#settings","text":"kubenav provides multiple settings, to customize the look and usage of the app.","title":"Settings"},{"location":"web/settings/#general","text":"Setting Description Values Default Theme Set the theme which should be used for kubenav. System , Dark , Light System Request Timeout (in seconds) The maximum time in seconds for a request. 10 - 120 60 Terminal Font Size (in px) The font size for the terminal. 8 - 48 12 Terminal Scrollback (in lines) The maximum number of lines to scrollback in the terminal. 1000 - 50000 10000 Enable Pod Metrics Enables or disables the metrics for Pods in list views. true , false true Limit The maximum number of items which can be queried per request. 100 - 1000 100 Refresh Interval (in seconds) The interval in which the data of views is refreshed. 30 - 600 300","title":"General"},{"location":"web/settings/#ssh","text":"Setting Description Default Port The port, which should be used for the SSH connection. 22 Private Key The private key, which should be used for the SSH connection. User The name of the user, which should be used for the SSH connection.","title":"SSH"}]}